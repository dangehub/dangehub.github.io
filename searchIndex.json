[
{
		"title": "在wordpress通过RSS来备份任何平台的信息，打造个人媒体枢纽",
		"date":"Wed Apr 24 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/自托管折腾/在wordpress通过RSS来备份任何平台的信息，打造个人媒体枢纽/",
		"content": "前言\n当年微博还是一个新兴事物，也并非现在新浪微博的缩写，而是microblog的中文名，而microblog顾名思义就是比blog/博客更轻量级的东西。\n在书写微博的时候，用户可以更没有压力，不用像写文章一样字斟句酌，而是可以用更口头化的、更肆意的字句来浇胸中块垒。\n记忆中，新浪博客曾经在个人文字媒体平台中占据了统治地位，而后它又推出了新浪轻博客，再然后才是新浪微博（那时候腾讯还有一个腾讯微博……）\n就在新浪微博飞速发展的时候，新浪悄无声息的关闭了新浪轻博客。而我在其中写的很多笔记都再也找不回来了。\n从那之后，我就对所有云托管类产品都产生了深深的不信任感。但是螳臂岂能当车，我们不得不承认大公司的产品在细节的雕琢上往往比个人产品更好，而且普通群众也很难承担各种服务的托管费用。因此我们大多数时候还是在使用这些产品。但是这些产品往往宽入严出，一旦进去了，就很难无损的把自己的作品再搬运出来。因此最好的办法就是在这些平台发布的时候，同时进行备份操作。\n今天我想探讨的就是如何在无压力使用各大平台的同时，完成数据的备份，为了体验的流畅性，这个备份一定要无感。也就是说我们只需要延续日常的使用，不需要每次手动进行任何额外的操作就能完成备份。\n在我长期的探索中，总结出了一套行之有效的办法：使用RSS抓取各平台信息，使用wordpress作为枢纽导入这些信息。\n借助RSS同步全平台\n同步多平台的核心原理是利用RSS抓取不同平台自己账号发布的内容，以实现备份全平台的信息。\n其中部分平台自带RSS，可以直接进入导入环节。\n但是也有很多平台是不提供RSS的，这个时候就需要使用其他工具，这里我一般采用RSShub来转换不支持RSS的网站。包括但不限于网易云音乐动态、新浪微博、酷安动态、Bilibili动态。\nRSShub的配置不再赘述，见官方文档即可。\n下面让我们看看具体如何导入RSS到wordpress。\nFeedzy插件实现（已废弃）\n使用Feedzy插件，注意两点：\n\nrss链接最后跟上/?feed_author=1，最后的数字是wordpress user ID，这样可以指定这个rss的作者是谁，1就是我的admin账号。如果不加的话，所有rss搬运过来会变成空用户，还得手动修改作者。\n发布时间选择item_date，这样rss的搬运内容会和原平台的发布时间同步，比如2024-04-23在wp搬运了一条2024-02-02的，就会变成在wp的2-2发布，而不是4-23，这样可以防止时间乱序。\n\n因为这个插件又要花钱，还有一些bug，不如下面那个插件，因此已放弃使用。\nwpematico插件实现\n设置的简易流程：\n\n在Feed URL添加要同步的平台rss链接\nCampaign选项中勾选使用Feed项目的时间与其子选项强制项日期，这一条是为了让wordperss中的发布时间由原贴时间控制，而不是rss导入的时间。\n作者设置为自己wordpress的用户\n设置计划任务\n文章模板建议如下设置，这样可以表示这是来自某某平台的同步备份贴，也能提供原链接地址，便于后续溯源。\n\n{content}\n&lt;a href=&quot;{permalink}&quot;&gt;跳转源&lt;/a&gt;&lt;br /&gt;\n\n把wordpress接入联邦宇宙，实现关注功能\n简单来说，联邦宇宙是一种通用协议，可以让Mastodon、Misskey等新兴的去中心化的微博平台互相链接，它使得不同平台互相关注成为了可能，而不是像传统的twitter/新浪微博/facebook等，只能在自家平台中互相关注。\n为了实现这个效果，我们需要安装几个插件：\n\nActivityPub：让wordpress可以与联邦宇宙通信\nEnable Mastodon Apps：允许通过 Mastodon 客户端访问您的 WordPress\nFriends：使wordpress可以关注其他联邦宇宙的对象\nFriends Mastodon-like Interface：friends的拓展插件，其实是一个仿mastodon的主题\n\n在安装完以上插件后，你的wordpress就可以当做一个mastodon来使用了。",
		"tags": [ "note","网站建设","wordpress","microblog"]
},

{
		"title": "密码管理器：从bitwarden迁移到keepass",
		"date":"Wed Apr 24 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/自托管折腾/密码管理器：从bitwarden迁移到keepass/",
		"content": "bitwarden到keepass的迁移\nbitwarden和keepass同为开源的支持自托管的密码管理器，keepass可以做到无服务端，因此我决定将我的密码库迁移到keepass，但是bitwarden直接导出的备份文件是不能把附件和totp等导入到keepass的，因此我们需要借助第三方项目来完成。\n项目地址：https://hub.docker.com/r/rogsme/bitwarden-to-keepass#!\n本项目在github上也有python版本，但是我更喜欢用docker解决这种有运行环境的东西。\n这里我采用windows的docker desktop，需要注意是本地文件挂载的写法\n下面附上我的启动命令：\ndocker run --rm -it -e BITWARDEN_URL=&quot;https://bitwarden.your.com/&quot; -v C:\\Users\\username\\Documents\\keepass:/exports rogsme/bitwarden-to-keepass\n\n其中BITWARDEN_URL是自托管的项目地址，如果不设置这个环境变量，则是从官方项目获取。\n启动docker后，需要手动输入新建keepass的密码、bitwarden的邮箱、bw的密码，然后等待完成后，就可以在挂载的目录下找到对应的kpdb文件，导入到keepass即可。\n多平台客户端的选择\n迁移之后就要考虑如何使用了，如何选择客户端，我主要参考了下面这篇文章。\n下表转自文章 不只为了省钱：开源密码管理器可用性报告\n\n平台\n推荐客户端\n\nWindows/Linux\nKeePassXC (开源免费，Qt 框架)\n\nmacOS\nStrongbox (开源，高级功能 €15/年或 €60 买断)KeePassXCKeePassium (开源，高级功能 $20/年或 $80 买断)\n\niOS\nStrongboxKeePassium\n\nAndroid\nKeepass2Android (开源免费)KeePassDX (开源免费，有捐赠版，$10 买断)\n\n浏览器\nStrongbox 自带 (Chromium、Firefox 和 Safari)KeePassXC-Browser (Chromium 和 Firefox)\n\n命令行\nKeePassXC 自带\n\n安卓端\n我对比了Keepass2Android和KeePassDX，前者界面比较古老，后者界面更好看，但是只有k2a支持多种云服务，而kpdx只支持本地文件（并且作者声明这是他的选择，为了更安全），云同步得自己用第三方软件实现。\n最后我选择使用了KeePassDX，然后采用Foldersync app实现同步，云盘使用我自己搭建的webdav。\nwin端\n最后我选择了KeePassXC这个客户端，因为它也比较好看，功能也全面。不过它有一个缺点：中英文混排时，部分英文字母会变的很奇怪。\n桌面：KeePassXC Password Manager\n浏览器装对应插件\n云同步的实现和备份\n采用Obcsapi的webdav\n将obcsapi同步到onedrive\n目录1:/mnt/onedrive\n目录2:/data/compose/obcsapi\n然后写个脚本，一直保活在后台监控 此方法已被废弃。\n#!/bin/bash\n\n# 源目录和目标目录\n\nSOURCE_DIR=&quot;/data/compose/obcsapi&quot;\n\nDESTINATION_DIR=&quot;/mnt/onedrive/obcsapi&quot;\n\n# 从源目录到目标目录的同步\n\nrsync -av --delete &quot;$SOURCE_DIR/&quot; &quot;$DESTINATION_DIR/&quot;\n\n# 从目标目录到源目录的同步\n\nrsync -av --delete &quot;$DESTINATION_DIR/&quot; &quot;$SOURCE_DIR/&quot;\n\n现在采用的备份方法是定期压缩并同步到onedrive，使用1panel自带的备份工具。",
		"tags": [ "note","自托管"]
},

{
		"title": "把Obsidian发布为网页的各种方式探索",
		"date":"Mon Aug 26 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/把Obsidian发布为网页的各种方式探索/",
		"content": "Obsidian发布方式汇总\n\n方式汇总\n优点\n缺点\n\n官方publish\n官方支持，稳定\n要花钱，数据非私有\n\ndigital garden\n更新稳定，支持功能多\n静态页面，无法即时渲染\n\nQuartz框架\n开发文档全面，可以自行\n静态页面，无法即时渲染\n\nperlite\n实时渲染，无需等待\n不支持dataview excalidraw等插件功能，需要服务器\n\n对于不想折腾的用户来说，只有一种方案：花钱买官方的publish。本文不再讨论这种方法。\n其实目前主流的Obsidian发布方案就是两种：\n\n通过后端支持实现实时渲染，只需要把ob的md源码上传就能马上看到最终效果\n通过渲染器把md源码编译成一个静态网页，然后把静态网页文件托管到某个平台，好处是网页加载快，缺点是每次增删改笔记都要重新编译，往往需要等待数分钟才能看到新的结果。\n\n因此如果发布前能保证已经完成了最终稿，那么静态发布是很好的选择。但是如果发布后还需要频繁修改，最好采用可即时编辑的工具。\n静态页面类\n如果你想要找一个能免费且私有数据的发布obsidian笔记的方案，这可能是最好也是唯一的选择。\n可以简单的把静态页面的发布方式理解为即食食品，只需要拿到这个“静态页面”就可以开袋即食，与之相对的，非静态页面的方法，需要服务器进行渲染操作，因此一般是很难找到支持非静态页面的、大公司提供的、免费的方案。\n其实静态页面发布博客的方法浩如星海，较为出名如Jekyll、Hugo、Hexo、Vuepress、Docsdify都是很成熟且有较多主题可以选择的，不过考虑到我们要发布obsidian笔记，当然需要支持obsidian的wiki链接功能，因此之后不再考虑这些没有针对obsidian优化的框架。\nDigital Garden插件\n项目地址：此插件已上架官方市场。\n优点：\n\n更新勤快，后续有支持\n功能多样\n\n支持导入ob主题\n支持excalidraw\n支持dataview\n\n缺点：\n\n依赖vercel（其实是可以使用github action的，不过需要一定动手能力）\n发布文章需要填写frontmatter，体验不够丝滑（可以使用模板来优化流程）\n\nQuartz框架\n项目地址：jackyzha0/quartz: 🌱 a fast, batteries-included static-site generator that transforms Markdown content into fully functional websites\n优点：\n\n原生美观程度是比digital garden高\n原生支持i18n，如果你需要发布多言语版本的文章，这点很重要\n\n缺点：\n\n不支持excalidraw\n不支持dataview\n\nObcsapi+对象存储\n项目地址：kkbt0/obcsapi-go: 基于 WebDAV，S3 存储或 CouchDb 的后端 API ，Obsidian 笔记的 API\n此方案来自和和恐咖兵糖的聊天\nobcsapi在对象存储模式下可以把渲染好的页面放在对象存储中，obsidian 额外生成一个索引并同步\n实时渲染类\nPerlite\n项目地址：secure-77/Perlite: A web-based markdown viewer optimized for Obsidian\n优势：\n\n实时，无需渲染\n可以直接把整个库复制进去，保留原库文件树\n\n缺点：\n\n支持的功能较少\n\nhtml标签不支持\ncanvas不支持\ntask语法不支持\ntodo语法不支持\n\n上次更新是7个月之前，疑似停更，支持力度更小\n\nObcsapi-publish功能\nobcsapi自带一个简易的publish页面，可以把指定目录的下笔记暴露在公开网络上。不过这个功能我并没有成功启动，暂时先记在这里。\n据说能配合lua脚本。\n采用第三方服务\n如果能接受把上述两种方案的幕后工作交与第三方进行，我们也可以使用一些方案，但是请注意，你使用其他人提供的免费服务，可能面临对方突然停止服务或数据丢失（如果发布后本地不再留档）的风险，因此我只建议将这些方式作为临时发布方案。\n已上架官方市场的插件：\n\nShare Note\nObsius Publish\nFriday\n……\n\n如果你想探索那些没有上架官方市场的插件，可以在github搜索obsidian，然后去topics里面查看，印象中前5页就有好几个发布用的项目。",
		"tags": [ "note","网站建设","obsidian","obsidian插件","自建博客"]
},

{
		"title": "Anyblock插件入门",
		"date":"Thu Oct 03 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Anyblock插件入门/",
		"content": "插件简介\nAnyblock是一个【无语法、可扩展、灵活强大、多平台】 的 Markdown 块扩展渲染插件。能实现无语法入侵的前提下，为obsidian实现更多渲染效果，例如表格、折叠、滚动、思维导图等。\n官方文档\n作者的博客： README | Linc 的小站\n作者自荐的帖子：列表转表格、树目录、思维导图、时间线、表格合并 —— Any Block V3（Ob/Md-it/VuePress/VitePress通用） - 经验分享 - Obsidian 中文论坛\n插件的开源地址：LincZero/obsidian-any-block.\n使用说明\n使用info语法召唤说明文档，如果你想看到渲染后的效果，应该在安装插件后，输入下面这段文字：\n[info]\n- 这是any block的文档\n\n然后应该会渲染出下面的效果：\n\n各效果器展示\n我只会在这里展示我常用的效果，更多内容参见插件自身的文档。\n文件树\n技巧 ：\n\n分隔左右侧的逗号是中文逗号\n逗号后有一个空格\n\n源代码 ：\n[list2dt]\n\n- vue-demo/\n- build/， 项目构建(webpack)相关代码\n- config/， 配置目录，包括端口号等。我们初学可以使用默认的\n- node_modules/， npm 加载的项目依赖模块\n- src/， 这里是我们要开发的目录\n- assets/， 放置一些图片，如logo等\n- components， 目录里面放了一个组件文件，可以不用\n- App.vue， 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录\n- main.js， 项目的核心文件。\n- static/， 静态资源目录，如图片、字体等\n- test/， 初始测试目录，可删除\n- .eslintignore\n- .gitignore， git配置\n- .index.html， 首页入口文件，你可以添加一些 meta 信息或统计代码啥的\n- package.json， 项目配置文件\n- READED.md， 项目的说明文档，markdown 格式&lt;br&gt;手动换行测试&lt;br&gt;自动换行测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试k\n- ...\n\n效果展示 ：\n\n超出折叠\n技巧 ：使用(300)这样的参数控制显示范围\n源代码：\n[overfold(300)]\n- 1\n- 2\n- 3\n- 4\n- 5\n- 6\n- 7\n- 8\n- 9\n- 10\n\n效果展示：\n滚动\n技巧：滚动也适用(300)这样的长度控制参数\n源代码：\n[scroll(300)]\n\n- 1\n- 2\n- 3\n- 4\n- 5\n- 6\n- 7\n- 8\n- 9\n- 10\n\n效果展示：",
		"tags": [ "note","obsidian插件"]
},

{
		"title": "口播剪辑工作流探索",
		"date":"Wed Oct 16 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/多媒体制作/口播剪辑工作流探索/",
		"content": "在产品介绍、课程录制类型的视频制作中，有一个绕不开的问题就是如何让视频更紧凑。要解决这个问题，无非两条路：前期保证一次成型或者后期剪辑。\n如果想节省后期功夫，前期就要写好逐字稿，并且保证实际录制时不能出现太多差错，诸如无意义的停顿和“嗯、啊、哦、呃、然后”等口头词的频繁出现。这对前期的准备工作量与演讲者的演讲能力提出了较高的要求。\n如果前期粗糙制作，后期的工作量就会增大。后期需要将这些没有意义的部分全部剪辑掉，完全依赖水磨功夫。因此我想找到一个能极大节省这种水磨功夫的工具。\n剪映有一个很好用的功能叫智能剪口播，能做到：\n\n转录字幕\n自动识别无意义的口头词与停顿\n一键剪辑掉上述无意义内容\n选择任意长度的字幕删除后，剪辑掉对应的视频片段\n\n目前全网我只知道剪映有这个功能，其他软件大多只在自动剪辑停顿（即气口）这个层面，还无法做到剪辑口头词。\n所以我在寻找能做到类似效果的开源项目，我找到两个项目：\n\nmli/autocut: 用文本编辑器剪视频\nHaujetZhao/QuickCut: Your most handy video processing software\n\nAutoCut能通过字幕的时间戳来反向剪辑视频，不过原项目没有图形化界面，可以去fork的这个项目：zcf0508/autocut-client: AutoCut Client 下载打包好的程序。\nQuickCut这个项目有一个比较有意思的功能，叫 辅助字幕自动剪辑，大概的工作原理是在前期录制的时候如果有一段出错了，当时就马上反应过来，然后在录制时说出对应的关键词进行标记，比如录了2分钟，发现有问题，就说一句 删除，然后再说2分钟，再说 保留，这样就会把第一个2分钟的片段剪辑掉。具体的效果展示可以参见作者的视频，不过这个功能的弊端也很明显：\n\n前期录制的时候要能判断哪些需要被删除\n\n对于下意义的停顿和与语气词无效\n但是上述的项目也只是基于whisper的句级剪辑，无法复刻剪映那种根据单字来剪辑视频的效果。\n\n不过我也看到有人和我有同样的想法：\n请问有没有选项可以做到一字一断呢 · Issue #84 · mli/autocut\n同时也有网友找到了可能有帮助的项目：\n\nlinto-ai/whisper-timestamped：具有字级时间戳和置信度的多语言自动语音识别 --- linto-ai/whisper-timestamped: Multilingual Automatic Speech Recognition with word-level timestamps and confidence\nm-bain/whisperX：WhisperX：带有字级时间戳的自动语音识别（和二值化） --- m-bain/whisperX: WhisperX: Automatic Speech Recognition with Word-level Timestamps (&amp; Diarization)\n不过既没有集成，也没有图形界面。\n\n目前来看，成熟的工具可能只有剪映。",
		"tags": ["84", "note","多媒体","软件"]
},

{
		"title": "我维护了一个obsidian示例库，分享了我的obsidian工作流",
		"date":"Mon Dec 16 2024 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/我维护了一个obsidian示例库，分享了我的obsidian工作流/",
		"content": "我使用obsidian也有很长时间了，有时候也有朋友会问我，你是如何使用obsidian的，于是我制作了这个示例库，里面有我的一些常用插件与脚本，如果你还没有总结出独属于你的obsidian工作流，或许它会有一点价值。\n使用方法也很简单：\n\n打开网址：dangehub/aqu_ob_share: Share my Obsidian techniques\n按图下载示例库\n解压此压缩包后，在obsidian中打开它\n具体细节请见库中README.md，也就是用obsidian打开它之后根目录的那篇笔记。",
		"tags": [ "note","obsidian","笔记软件"]
},

{
		"title": "用css让obsidian中的扫描黑白文档融入笔记背景",
		"date":"Mon Jan 06 2025 00:00:00 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/用css让obsidian中的扫描黑白文档融入笔记背景/",
		"content": "从• Discord | &quot;Diff geom notes :D&quot; | Obsidian Members Group (OMG)学习到的小技巧\n新建一个css文件：\n.has-scan img {\nmix-blend-mode : multiply\n}\n\n然后在笔记属性中添加：\n---\ncssclasses: has-scan\n---\n\n然后就可以在笔记的阅读视图下看到会跟随obsidian主题背景变化的图片了。\n据作者说如果需要在实时视图中生效（但是在我这里没有生效， 原因未知），可以把css改为：\n.has-scan .internal-embed.media-embed.image-embed.is-loaded {\nbackground: var(--background-primary);\n}\n\n下面是效果展示：\n\n未启用效果\n启用后效果\n\n这种方式特别适合扫描产生的黑白线稿图片。",
		"tags": [ "note","CSS","obsidian","美化"]
},

{
		"title": "用 n8n 实现反思翻译",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/AI/用n8n实现反思翻译/",
		"content": "用 defy 搭建三步翻译老是报错，想自托管发现 defy 的配置要求很高，于是准备先用之前的 n 8 n 试试。\n更新 n 8 n：1.0.4 更新到 1.44.1\n![](/img/user/101-日记/assets/Pasted image 20240806214536.png)\n采用这样的结构时，会报错 Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter\n感觉像是个 bug，明明已经能读取前两个节点的输出，但是 n 8 n 还是提示无法读取到上上个节点。然后细查日志发现报错\nNodeOperationError: No prompt specified at getPromptInputByType (/usr/local/lib/node_modules/n8n/node_modules/@n8n/n8n-nodes-langchain/dist/utils/helpers.js:71:15) at Object.execute (/usr/local/lib/node_modules/n8n/node_modules/@n8n/n8n-nodes-langchain/dist/nodes/chains/ChainLLM/ChainLlm.node.js:412:65) at Workflow.runNode (/usr/local/lib/node_modules/n8n/node_modules/n8n-workflow/dist/Workflow.js:728:19) at /usr/local/lib/node_modules/n8n/node_modules/n8n-core/dist/WorkflowExecute.js:673:51 at /usr/local/lib/node_modules/n8n/node_modules/n8n-core/dist/WorkflowExecute.js:1086:20\n\n后面我发现问题来自于 prompt 的设置，原来每个 llm chain 一开始就有一个 prompt 设置，而默认是继承自上一个节点，而我的第一个 llm chain 节点就没设置它。\n![](/img/user/101-日记/assets/Pasted image 20240806221817.png)\n搞定后展示一下翻译效果：\n\n原文：\n\nIt’s so creepy and weird. I’ll go back and play DoDS and HL 2 DM etc and it’s still like a chat room while you play, it makes gaming so much more casual and enjoyable. I play this game and try to engage in any way and get literally no response from anyone. Is it just because this is a newer game so it’s full of antisocial teenagers who don’t know how to talk to each other? I just honestly don’t get it. It’s not that you’re obligated to chat, but it seems very weird to pretend that you’re not playing with other human beings.\nEdit: I actually think this is why I lose interest in this game so quickly. In the old school games my team could be getting destroyed but it doesn’t bother me because we’re all chatting and having a good time. In this game it’s just silence anyway, doesn’t even feel like I’m playing against actual people so I don’t feel bad leaving in the middle of a match if we’re getting rolled.\n\nGoogle 翻译：\n这太令人毛骨悚然和奇怪了。我会回去玩 DoDS 和 HL 2 DM 等游戏，玩的时候它仍然像一个聊天室，它让游戏变得更加休闲和愉快。我玩这个游戏并尝试以任何方式参与，但几乎没有得到任何人的回应。难道只是因为这是一款较新的游戏，所以里面充满了不知道如何与对方交谈的反社会青少年？老实说我不明白。这并不是说你有义务聊天，但假装你没有和其他人一起玩似乎很奇怪。\n编辑：我实际上认为这就是我这么快对这款游戏失去兴趣的原因。在老式的学校比赛中，我的球队可能会被摧毁，但这并不困扰我，因为我们都在聊天，玩得很开心。无论如何，在这款游戏中，一切都是沉默，甚至感觉不到我是在和真人比赛，所以如果我们被淘汰，我不会因为在比赛中途离开而感到难过。\n\n三步翻译：\n实在是太奇怪而且让人有点不舒服了。回想当年玩《DoD:S》和《HL 2 DM》等游戏的时候，那种体验就像是在一间聊天室里面玩游戏，让整个游戏玩起来更加轻松且愉快。但当我玩这款游戏时，不管我怎么试图互动，却几乎得不到任何人的回应。难道仅仅因为这是一款新游戏，所以里面都是些不太愿意交流彼此的社恐少年吗？我真的搞不清楚是怎么回事。我不是说大家必须聊天，但完全假装没有和其他玩家一起玩的感觉总是让人觉得有点别扭。\n编辑：我想这可能是导致我对这款游戏兴趣迅速消退的原因之一吧。在游戏中，即便是我们队伍大败亏输，我也不至于特别沮丧，因为我们那时都在愉快地聊天。但在这款游戏中，整个世界就像是一片寂静，根本感受不到自己是在跟其他玩家对战，所以我们遭受挫败时，我中途退出时也就没有什么内疚感了。\n\n下面展示一下三步翻译的过程：\n\n直译：\n真是太诡异又让人不舒服。我回到过去玩 DoDS 和 HL 2 DM 等游戏时，感觉就像在一个聊天室里游戏，这让整个游戏体验变得更加轻松愉快。然而玩这款游戏时，无论我怎样尝试互动，却几乎得不到任何人的回应。难道仅仅因为这是一款新游戏，所以满是那些不懂得彼此交谈的社交恐惧少年？我真的不明白这是怎么回事。我不是说大家非得聊天不可，只是假装没有和其他玩家一起游戏，总让我觉得有些奇怪。\\n\\n 编辑：我想明白了，这可能就是我迅速对这个游戏失去兴趣的原因。在以前的老游戏中，即使我的队伍被杀得人仰马翻，我也不会感到烦闷，因为我们都在欢快地聊天。而在这款游戏中，四周一片寂静，根本感受不到是在和真人对战，所以我们被碾压时，我中途离开也不会有丝毫的愧疚感。\n\n然后是用 ai 进行反思：\n&lt;直接翻译&gt;中存在的问题:\\n\\n 1. 不符合中文的表达习惯:\\n - &quot; 真是太诡异又让人不舒服 &quot;：中文通常不以 &quot; 真是太...&quot; 这样的句式表达负面强烈的情感。\\n \\n 2. 句子结构笨拙:\\n - &quot; 我玩这款游戏时，无论我怎样尝试互动，几乎得不到任何人的回应 &quot;：应改为“当我玩这款游戏时，无论怎样尝试互动，几乎得不到任何人的回应”更加自然流畅。\\n \\n 3. 表达含糊不清，难以理解：\\n - &quot; 难道仅仅因为这是一款新游戏, 所以满是那些不懂得彼此交谈的社交恐惧少年?&quot; : 整个句子表达过于生硬，不易于理解其意图。\\n - &quot; 而这款游戏中, 四周一片寂静, 根本感受不到是在和真人对战 &quot;: 这里使用“真人”来指代其他在线玩家显得较为突兀且不自然。一般情况下，在这种语境中并不会强调对战的对象是否为真实的人，因为在网络游戏中默认就是与真人对战。\\n\\n 4. 表达不够地道：\\n - &quot; 所以, 我们被碾压时, 我中途离开也不会有丝毫的愧疚感 &quot; : 愧疚感的表达在此处显得过于严肃，通常在网络游戏中玩家们会更倾向于用更加随意的语气来描述此类情况。\\n\\n 注: 以上指出的问题并未提供修改后的版本。\n\n此处我采用的是通义千问的 qwen-long 模型，它的实力在目前的 llm 中算不上非常强劲，这正好能说明三步翻译的强劲实力。\n2024-09-01 更新 我参考 FastGPT 又做了一个 n8n 三步翻译，同样使用 qwen-long，得到的翻译结果如下：\n这真是有点怪。我回到老游戏像《战斗要塞》（DoDS）和《半条命2: 死亡竞赛》之类的，游戏里还是像聊天室一样，感觉特别轻松。玩这款游戏我试着跟人互动，却完全没人搭理我。是因为这是款新游戏，里面都是些不会社交的青少年吗？真搞不懂。虽然不是一定要聊天，但在游戏里忽略其他人存在也很古怪。\n\n补充：我想，这才是我对这游戏兴致全无的原因了。以前玩老游戏时，哪怕队伍输得很惨，大家说说笑笑也觉得开心。在这新游戏里基本没人说话，感觉就像和机器对打，输了也不觉得可惜，想退随时能走。\n\n这段翻译的效果整体来说比上一个版本还要好，就是最后一句话有点问题，感觉这句话的原意是“因为大家很糟糕，所以我中途退赛也不会有心理压力”\n做成 api 来配合划词翻译\n先启动 n 8 n 的测试模式，然后用划词翻译发送一次，得到划词翻译的发包格式\n&quot;body&quot;: {\n\n&quot;model&quot;: &quot;qwen-long&quot;,\n\n&quot;messages&quot;: [\n\n{\n\n&quot;role&quot;: &quot;user&quot;,\n\n&quot;content&quot;: &quot;This is an embeddable Chat widget for n8n. It allows the execution of AI-Powered Workflows through a Chat window.&quot;\n\n}\n\n然后需要根据格式调整 n8n\nn8n 自动翻译完之后的输出为\n\n[\n\n{\n\n&quot;text&quot;: &quot;&lt;改进翻译&gt;\\n\\n这是一款专为 n8n 设计的、可嵌入式的聊天工具，它使用户能够在聊天窗口内执行由人工智能驱动的工作流程。\\n\\n在这个版本里解决了以下问题：\\n1. 调整了“可嵌入式”的位置，使之更符合中文的语言习惯。\\n2. 简化并调整了句子结构，将“它能让用户通过聊天窗口来运行由人工智能驱动的工作流程”改写为更贴合中文表达习惯和流畅度的表述：“它使用户能够在聊天窗口内执行由人工智能驱动的工作流程”。\\n3. 增强了句子之间逻辑关系的连贯性。&quot;\n\n}\n\n]\n\n而划词翻译需要接受来自 openai 格式的 json，因此需要把上面 n8n 的输出转换一下。\nopenai 格式参考为:\n{\n&quot;id&quot;: &quot;b3e86c70-bd28-995b-a6e9-c47ab55c6495&quot;,\n&quot;model&quot;: &quot;qwen&quot;,\n&quot;object&quot;: &quot;chat.completion&quot;,\n&quot;created&quot;: 1722959731,\n&quot;choices&quot;: [\n{\n&quot;index&quot;: 0,\n&quot;message&quot;: {\n&quot;role&quot;: &quot;assistant&quot;,\n&quot;content&quot;: &quot;Hello! How can I assist you today?&quot;\n},\n&quot;finish_reason&quot;: &quot;stop&quot;\n}\n],\n&quot;usage&quot;: {\n&quot;prompt_tokens&quot;: 1,\n&quot;completion_tokens&quot;: 9,\n&quot;total_tokens&quot;: 10\n}\n}\n\n注意，在 http request 中不能使用引号和换行。\n在 prompt 中要求不要使用引号，然后用节点来处理换行符，最后得到效果如下：![](/img/user/105-极客/LLM/assets/Pasted image 20240807013225.png)\n可以看到这个效果已经相当好了。\n不要相信 ai 的效果，引号与换行符都要用正则直接去掉。\n{{ $json.text.replace(/(?:\\&quot;|(?:\\r\\n|\\\\r|\\\\n|\\n))/g, '')}}\n\n2025-01-01 更新：\n在 mac 上使用 bob，但是发现它也不能自己做三步翻译，只能用 chatgpt 直接翻译，这次我再做一个对比：",
		"tags": [ "note","geek","翻译","大语言模型","LLM","反思翻译法"]
},

{
		"title": "Obsidian 实现复制时自动上传图片到图床",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Obsidian实现复制时自动上传图片到图床/",
		"content": "Obsidian 实现复制时自动上传图片到图床\n【QuickAdd脚本】带图复制-自动上传图片到图床 - 经验分享 - Obsidian 中文论坛\n我新开一个库可以用，但是在主力库里就不行，报错为\n\nQuickAdd: (ERROR) failed to run user script 带\n图复制.Error:\nThe “path&quot; argument must be of type string.\nReceived undlefined\n\n这个问题很奇怪，我在新开的空白 ob 库里没有遇见，但是在主力库就有这个问题。\n怎么排查问题？\n\n尝试删除 js 脚本后再执行命令，看看是不是脚本的问题——删除后报错找不到脚本，看来不是这个问题。\n\n然后我想为什么空白库是对的，多半是插件或者设置的问题，然后我把脚本发给 kimi，kimi 分析到一个关键点，就是文件路径。\n于是我发现问题了：试用的时候发现一个问题：\n如果 内部链接类型 设置为 基于当前笔记的相对路径，脚本会报错\nQuickAdd: (ERROR) failed to run user script 带图 复制.Error: The “path&quot; argument must be of type string. Received undefined\n采用绝对路径也会有同样问题。改为尽量短路径就正常了。\n用 chatgpt 修复这个 bug（还得是 chatgpt 哇），修复版的脚本为：\nconst path = require('path');\nconst quickAddApi = app.plugins.plugins.quickadd.api;\nconst { editor, file, containerEl } = app.workspace.activeEditor;\nconst url = &quot;http://127.0.0.1:36677/upload&quot;;\n\nmodule.exports = async () =&gt; {\nconst files = app.vault.getFiles();\nlet selection = &quot;&quot;;\nlet content = &quot;&quot;;\nselection = editor.getSelection();\nconsole.log(&quot;Selected text:&quot;, selection);\n\nfor (let line of selection.split(&quot;\\n&quot;)) {\nlet embed = &quot;&quot;;\nif (line) {\nembed = matchSelectionEmbed(line);\n}\nconsole.log(&quot;Matched embed:&quot;, embed);\n\nif (embed &amp;&amp; /\\.(png|jpg|jpeg|gif|bmp)$/.test(embed)) {\nlet wikiPath = getFilePath(files, embed); // 匹配Wiki链接\nif (!wikiPath) {\nnew Notice(`❌无法找到文件: ${embed}`);\nconsole.log(`❌无法找到文件: ${embed}`);\ncontinue;\n}\n\n// 获取绝对路径\nconst imgPath = app.vault.adapter.getFullPath(wikiPath);\nconsole.log(&quot;Image path:&quot;, imgPath);\n\nconst data = await uploadFiles([imgPath], url);\nif (data.success) {\nconst imgWiki = `![[${embed}]]`;\nconst imgLink = `![${embed}](${data.result})`;\nline = line.replace(imgWiki, imgLink);\n} else {\nnew Notice(`❌上传 ${path.basename(imgPath)} 图片失败`);\nconsole.log(`❌上传 ${path.basename(imgPath)} 图片失败`);\n}\n}\ncontent += line + &quot;\\n&quot;;\n}\n\nconsole.log(&quot;Final content:&quot;, content);\ncopyToClipboard(content)\nnew Notice(`✅复制成功`);\n};\n\n// 获取文件路径函数\nfunction getFilePath(files, baseName) {\nlet matchingFiles = files.filter(f =&gt; {\nconst fullPath = f.path;\nconsole.log(`Comparing ${fullPath} with ${baseName}`);\nreturn fullPath.endsWith(baseName);\n});\n\nif (matchingFiles.length === 0) {\nconsole.log(`No files matched for: ${baseName}`);\nreturn undefined;\n}\n\nreturn matchingFiles[0].path;\n}\n\nfunction matchSelectionEmbed(text) {\nconst regex = /!\\[\\[?([^\\]]*?)(\\|.*)?\\]\\]?\\(?([^)\\n]*)\\)?/;\nconst matches = text.match(regex);\nif (!matches) return;\nif (matches[3]) return decodeURIComponent(matches[3]);\nif (matches[1]) return decodeURIComponent(matches[1]);\n}\n\nasync function uploadFiles(imagePathList, url) {\nconst response = await requestUrl({\nurl: url,\nmethod: &quot;POST&quot;,\nheaders: { &quot;Content-Type&quot;: &quot;application/json&quot; },\nbody: JSON.stringify({ list: imagePathList }),\n});\nconst data = response.json; // 直接访问 `json` 属性，而不是调用 `json()` 方法\nreturn data;\n};\n\nfunction copyToClipboard(extrTexts) {\nconst txtArea = document.createElement('textarea');\ntxtArea.value = extrTexts;\ndocument.body.appendChild(txtArea);\ntxtArea.select();\nif (document.execCommand('copy')) {\nconsole.log('copy to clipboard.');\n} else {\nconsole.log('fail to copy.');\n}\ndocument.body.removeChild(txtArea);\n}\n\n使用方法\n\n安装插件 quickadd\n在 quickadd 中设置脚本存放目录 Template Folder Path，然后在对应目录下新建 带图复制.js，把代码粘贴进去\n新建一个宏，选择刚刚新建的脚本\n安装 piclist，配置好图床\n在 obsidian 中选中要分享的文本，其中需要包含要上传的图片，然后 ctrl+p 使用脚本\n粘贴即可\n\n直接把图片上传到 github\n用 github publisher 插件能把图片上传到 github，但是图片在文章中的格式是 [[]] 的 wiki 链接，因此我们需要通过正则的方式来转换格式。\n参考这篇文章 obsidian图片链接转换成markdown语法，不关闭wiki链接_obsidian图片显示变成链接-CSDN博客\n同时上面这个方法还可以解决这个问题：obsidian 粘贴进来的图片名字会自动带空格，如 Pasted image 20240806221817.png\n最后发布后就能看到在 github 是可以正常查看图片了，但是为了同步到其他平台，可以批量的在图片路径前面加上 https://github.com/dangehub/github2wp/blob/main/_posts\n方法也很简单，就是搜索 assets/，然后替换为 https://github.com/dangehub/github2wp/blob/main/_posts/assets/\n\n但是为什么同步到 wordpress 的文章里图片没有了？\n\n同步到 wp 的是 html 代码：\n&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/dangehub/github2wp/blob/main/_posts/assets/Pasted%20image%2020240806214536.png&quot; /&gt;&lt;/p&gt;\n\n直接访问这个链接是对的，但是这段 html 代码不能正常工作。\n比如放到 obsidian 中：\n\n上面的分隔线中就是这段 html 代码，无法显示图像。为什么？\n去调试台看了下，报错 （失败）net::ERR_BLOCKED_BY_ORB，这是跨域问题\n但是都没人说 github 的图片会限制跨域，检查之后发现 https://github.com/dangehub/github2wp/blob/b85405e3ef0c15a3caf57a038a545e0842d43996/_posts/assets/Pasted%20image%2020240806214536.png 指向的不是图片本身，https://github.com/dangehub/github2wp/blob/b85405e3ef0c15a3caf57a038a545e0842d43996/_posts/assets/Pasted%20image%2020240806214536.png?raw=true 才是图片本身，替换为这个链接就好了。\n即用 png?raw=true 替换 png",
		"tags": [ "note","geek"]
},

{
		"title": "Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地/",
		"content": "前言\n今天在学习隐写术的时候看到一篇挺有价值的文章，本来想用 ob 官方的剪藏工具保存下来，但是发现官方工具到现在还不能把网络图片下载下来，这对于剪藏防丢失这个目的来说，这种级别就是不可用的，于是还是换工具了，调研了一下，发现 maoxian 可能是最适合我的。\nmaoxian 的优势：\n\n在浏览器环境下下载图片，可以使用浏览器的代理、cookie 等环境信息，做到所见即可得\n开源\n文件保存的名称、内容格式、路径高度可自定义\n\nmaoxian web clipper 配置过程记录\nObsidian 库： C:\\Users\\62300\\Documents\\livesync\n网摘入口：C:\\Users\\62300\\Documents\\livesync\\201-文章摘录\n浏览器默认下载地址：C:\\Users\\62300\\Downloads\nmaoxian 根目录：maoxian摘录\n你需要根据电脑的用户名、obsidian 库名称、剪藏存放的文件夹来替换部分内容。\n创建软链接（路径有中文就必须要有引号）\nmklink /D &quot;C:\\Users\\62300\\Downloads\\maoxian摘录&quot; &quot;C:\\Users\\62300\\Documents\\livesync\\201-文章摘录&quot;\n\n调整 maoxian 的设置，由于内容过多，我直接把我的配置文件贴在文章末尾，详见 <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地/#maoxian\">Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地#我的maoxian配置文件</a>\n我的 maoxian 配置文件\n使用方法：保存为 json 文件后到 maoxian 的备份中导入\n[fold]\n{\n&quot;data&quot;: {\n&quot;assistant.default-tag-status&quot;: &quot;&quot;,\n&quot;assistant.public-plan.default.20240502&quot;: [\n{\n&quot;actions&quot;: [\n{\n&quot;hide&quot;: [\n&quot;div#toc&quot;,\n&quot;table.infobox&quot;,\n&quot;span.mw-editsection&quot;,\n&quot;table.navbox&quot;,\n&quot;div.thumb&quot;,\n&quot;div.dablink&quot;,\n&quot;table.metadata&quot;\n]\n},\n{\n&quot;pick&quot;: &quot;div.mw-parser-output&quot;\n}\n],\n&quot;excludePattern&quot;: &quot;https://*.m.wikipedia.org/*/&quot;,\n&quot;name&quot;: &quot;wikipedia.org&quot;,\n&quot;pattern&quot;: &quot;https://*.wikipedia.org/wiki/*&quot;,\n&quot;tags&quot;: [\n&quot;knowledge&quot;,\n&quot;wiki&quot;\n],\n&quot;version&quot;: 20240502\n},\n{\n&quot;actions&quot;: [\n{\n&quot;hide&quot;: [\n&quot;.page-actions-menu&quot;,\n&quot;#toc&quot;,\n&quot;.mw-editsection&quot;,\n&quot;h2 &gt; div.mw-ui-icon&quot;,\n&quot;table.box-Unreferenced&quot;,\n&quot;table.box-More_citations_needed&quot;\n]\n},\n{\n&quot;chAttr&quot;: {\n&quot;attr&quot;: &quot;style&quot;,\n&quot;pick&quot;: &quot;h2.section-heading&quot;,\n&quot;sep&quot;: &quot;;&quot;,\n&quot;type&quot;: &quot;split2list.add&quot;,\n&quot;value&quot;: &quot;width: 100%&quot;\n}\n}\n],\n&quot;contributors&quot;: [\n&quot;Altair Wei (author)&quot;\n],\n&quot;name&quot;: &quot;Wikipedia Mobile View&quot;,\n&quot;pattern&quot;: &quot;https://*.m.wikipedia.org/*/&quot;,\n&quot;tags&quot;: [\n&quot;knowledge&quot;,\n&quot;wiki&quot;\n],\n&quot;version&quot;: 20240502\n},\n{\n&quot;actions&quot;: [\n{\n&quot;hide&quot;: [\n&quot;.avatar&quot;,\n&quot;.avatar-parent-child&quot;,\n&quot;.inline-comment-form-actions&quot;,\n&quot;.flex-items-center.d-sm-flex.d-none&quot;,\n&quot;.d-inline-block&quot;\n]\n},\n{\n&quot;pick&quot;: [\n&quot;.js-discussion&quot;,\n&quot;.markdown-body&quot;\n]\n}\n],\n&quot;contributors&quot;: [\n&quot;yzqzss (author)&quot;\n],\n&quot;name&quot;: &quot;Github&quot;,\n&quot;pattern&quot;: &quot;https://github.com/&quot;,\n&quot;tags&quot;: [\n&quot;IT&quot;,\n&quot;geek&quot;,\n&quot;git&quot;\n],\n&quot;version&quot;: 20240502\n},\n{\n&quot;actions&quot;: [\n{\n&quot;pick&quot;: &quot;#bodyContent&quot;\n}\n],\n&quot;contributors&quot;: [\n&quot;Mika&quot;\n],\n&quot;name&quot;: &quot;ArchWiki&quot;,\n&quot;pattern&quot;: &quot;https://wiki.archlinux.org/title/*&quot;,\n&quot;tags&quot;: [\n&quot;IT&quot;,\n&quot;wiki&quot;,\n&quot;doc&quot;\n],\n&quot;version&quot;: 20240502\n}\n],\n&quot;assistant.public-plan.default.latest&quot;: &quot;assistant.public-plan.default.20240502&quot;,\n&quot;assistant.public-plan.default.text&quot;: &quot;[\\n {\\n \\&quot;name\\&quot;: \\&quot;wikipedia.org\\&quot;,\\n \\&quot;pattern\\&quot;: \\&quot;https://*.wikipedia.org/wiki/*\\&quot;,\\n \\&quot;excludePattern\\&quot;: \\&quot;https://*.m.wikipedia.org/*/\\&quot;,\\n \\&quot;version\\&quot;: 20240502,\\n \\&quot;actions\\&quot;: [\\n {\\n \\&quot;hide\\&quot;: [\\n \\&quot;div#toc\\&quot;,\\n \\&quot;table.infobox\\&quot;,\\n \\&quot;span.mw-editsection\\&quot;,\\n \\&quot;table.navbox\\&quot;,\\n \\&quot;div.thumb\\&quot;,\\n \\&quot;div.dablink\\&quot;,\\n \\&quot;table.metadata\\&quot;\\n ]\\n },\\n {\\n \\&quot;pick\\&quot;: \\&quot;div.mw-parser-output\\&quot;\\n }\\n ],\\n \\&quot;tags\\&quot;: [\\n \\&quot;knowledge\\&quot;,\\n \\&quot;wiki\\&quot;\\n ]\\n },\\n {\\n \\&quot;name\\&quot;: \\&quot;Wikipedia Mobile View\\&quot;,\\n \\&quot;pattern\\&quot;: \\&quot;https://*.m.wikipedia.org/*/\\&quot;,\\n \\&quot;version\\&quot;: 20240502,\\n \\&quot;actions\\&quot;: [\\n {\\n \\&quot;hide\\&quot;: [\\n \\&quot;.page-actions-menu\\&quot;,\\n \\&quot;#toc\\&quot;,\\n \\&quot;.mw-editsection\\&quot;,\\n \\&quot;h2 &gt; div.mw-ui-icon\\&quot;,\\n \\&quot;table.box-Unreferenced\\&quot;,\\n \\&quot;table.box-More_citations_needed\\&quot;\\n ]\\n },\\n {\\n \\&quot;chAttr\\&quot;: {\\n \\&quot;type\\&quot;: \\&quot;split2list.add\\&quot;,\\n \\&quot;pick\\&quot;: \\&quot;h2.section-heading\\&quot;,\\n \\&quot;attr\\&quot;: \\&quot;style\\&quot;,\\n \\&quot;value\\&quot;: \\&quot;width: 100%\\&quot;,\\n \\&quot;sep\\&quot;: \\&quot;;\\&quot;\\n }\\n }\\n ],\\n \\&quot;tags\\&quot;: [\\n \\&quot;knowledge\\&quot;,\\n \\&quot;wiki\\&quot;\\n ],\\n \\&quot;contributors\\&quot;: [\\n \\&quot;Altair Wei (author)\\&quot;\\n ]\\n },\\n {\\n \\&quot;name\\&quot;: \\&quot;Github\\&quot;,\\n \\&quot;pattern\\&quot;: \\&quot;https://github.com/\\&quot;,\\n \\&quot;version\\&quot;: 20240502,\\n \\&quot;actions\\&quot;: [\\n {\\n \\&quot;hide\\&quot;: [\\n \\&quot;.avatar\\&quot;,\\n \\&quot;.avatar-parent-child\\&quot;,\\n \\&quot;.inline-comment-form-actions\\&quot;,\\n \\&quot;.flex-items-center.d-sm-flex.d-none\\&quot;,\\n \\&quot;.d-inline-block\\&quot;\\n ]\\n },\\n {\\n \\&quot;pick\\&quot;: [\\n \\&quot;.js-discussion\\&quot;,\\n \\&quot;.markdown-body\\&quot;\\n ]\\n }\\n ],\\n \\&quot;tags\\&quot;: [\\n \\&quot;IT\\&quot;,\\n \\&quot;geek\\&quot;,\\n \\&quot;git\\&quot;\\n ],\\n \\&quot;contributors\\&quot;: [\\n \\&quot;yzqzss (author)\\&quot;\\n ]\\n },\\n {\\n \\&quot;name\\&quot;: \\&quot;ArchWiki\\&quot;,\\n \\&quot;pattern\\&quot;: \\&quot;https://wiki.archlinux.org/title/*\\&quot;,\\n \\&quot;version\\&quot;: 20240502,\\n \\&quot;actions\\&quot;: [\\n {\\n \\&quot;pick\\&quot;: \\&quot;#bodyContent\\&quot;\\n }\\n ],\\n \\&quot;tags\\&quot;: [\\n \\&quot;IT\\&quot;,\\n \\&quot;wiki\\&quot;,\\n \\&quot;doc\\&quot;\\n ],\\n \\&quot;contributors\\&quot;: [\\n \\&quot;Mika\\&quot;\\n ]\\n }\\n]&quot;,\n&quot;assistant.public-plan.pointers&quot;: [\n&quot;assistant.public-plan.default.20240502&quot;\n],\n&quot;assistant.public-plan.subscription-urls&quot;: [\n&quot;https://mika-cn.github.io/maoxian-web-clipper/assistant/plans/default/index.json&quot;\n],\n&quot;assistant.public-plan.subscriptions&quot;: [\n{\n&quot;description&quot;: &quot;Default channel hosts plans that relative to international websites&quot;,\n&quot;latestVersion&quot;: 20240502,\n&quot;name&quot;: &quot;default&quot;,\n&quot;size&quot;: 4,\n&quot;updateUrl&quot;: &quot;https://mika-cn.github.io/maoxian-web-clipper/assistant/plans/default/20240502.json&quot;,\n&quot;url&quot;: &quot;https://mika-cn.github.io/maoxian-web-clipper/assistant/plans/default/index.json&quot;\n}\n],\n&quot;config&quot;: {\n&quot;allowFileSchemeAccess&quot;: true,\n&quot;assetFileName&quot;: &quot;$TIME-INTSEC-$MD5URL$EXT&quot;,\n&quot;assetFolder&quot;: &quot;$ROOT-FOLDER/assets&quot;,\n&quot;assistantEnabled&quot;: false,\n&quot;autoInputLastCategory&quot;: true,\n&quot;autoInputLastTags&quot;: true,\n&quot;autoRefreshHistory&quot;: false,\n&quot;autoRunContentScripts&quot;: false,\n&quot;autoUpdatePublicPlan&quot;: false,\n&quot;autogenerateClippingJs&quot;: false,\n&quot;backupAssistantData&quot;: true,\n&quot;backupHistoryPageConfig&quot;: true,\n&quot;backupSelectionData&quot;: true,\n&quot;backupSettingPageConfig&quot;: true,\n&quot;clippingFolderName&quot;: &quot;$YYYY-$MM-$DD-$TIME-INTSEC&quot;,\n&quot;clippingHandler&quot;: &quot;Browser&quot;,\n&quot;clippingJsPath&quot;: &quot;$STORAGE-PATH/history/clippings.js&quot;,\n&quot;communicateWithThirdParty&quot;: false,\n&quot;defaultCategory&quot;: &quot;default&quot;,\n&quot;frameFileFolder&quot;: &quot;$ROOT-FOLDER/frames&quot;,\n&quot;frameFileName&quot;: &quot;$TIME-INTSEC-$MD5URL.frame.html&quot;,\n&quot;handlerBrowserEnabled&quot;: true,\n&quot;handlerNativeAppEnabled&quot;: false,\n&quot;handlerWizNotePlusEnabled&quot;: false,\n&quot;htmlCaptureApplet&quot;: &quot;remove&quot;,\n&quot;htmlCaptureAudio&quot;: &quot;remove&quot;,\n&quot;htmlCaptureCssImage&quot;: &quot;remove&quot;,\n&quot;htmlCaptureCssRules&quot;: &quot;saveUsed&quot;,\n&quot;htmlCaptureEmbed&quot;: &quot;saveImage&quot;,\n&quot;htmlCaptureIcon&quot;: &quot;remove&quot;,\n&quot;htmlCaptureImage&quot;: &quot;saveAll&quot;,\n&quot;htmlCaptureObject&quot;: &quot;saveImage&quot;,\n&quot;htmlCaptureVideo&quot;: &quot;remove&quot;,\n&quot;htmlCaptureWebFont&quot;: &quot;remove&quot;,\n&quot;htmlCompressCss&quot;: false,\n&quot;htmlCustomBodyBgCssEnabled&quot;: false,\n&quot;htmlCustomBodyBgCssValue&quot;: &quot;#000000&quot;,\n&quot;htmlEmbedFilter&quot;: &quot;&lt;images&gt;&quot;,\n&quot;htmlObjectFilter&quot;: &quot;&lt;images&gt;&quot;,\n&quot;htmlSaveClippingInformation&quot;: false,\n&quot;htmlWebFontFilterList&quot;: &quot;woff2|woff|otf|ttf&quot;,\n&quot;infoFileFolder&quot;: &quot;$CLIPPING-PATH&quot;,\n&quot;infoFileName&quot;: &quot;index.json&quot;,\n&quot;mainFileFolder&quot;: &quot;$ROOT-FOLDER&quot;,\n&quot;mainFileName&quot;: &quot;$TITLE.$FORMAT&quot;,\n&quot;markdownOptionBulletListMarker&quot;: &quot;-&quot;,\n&quot;markdownOptionCodeBlockStyle&quot;: &quot;fenced&quot;,\n&quot;markdownOptionEmDelimiter&quot;: &quot;*&quot;,\n&quot;markdownOptionFence&quot;: &quot;```&quot;,\n&quot;markdownOptionFormulaBlockWrapper&quot;: &quot;padSameLine&quot;,\n&quot;markdownOptionHeadingStyle&quot;: &quot;atx&quot;,\n&quot;markdownOptionHr&quot;: &quot;- - -&quot;,\n&quot;markdownOptionLinkReferenceStyle&quot;: &quot;full&quot;,\n&quot;markdownOptionLinkStyle&quot;: &quot;inlined&quot;,\n&quot;markdownOptionPreformattedCode&quot;: false,\n&quot;markdownOptionStrongDelimiter&quot;: &quot;**&quot;,\n&quot;markdownTemplate&quot;: &quot;\\n{{content}}\\n&quot;,\n&quot;mouseModeEnabled&quot;: true,\n&quot;offlinePageHandler&quot;: &quot;Browser&quot;,\n&quot;refreshHistoryHandler&quot;: &quot;NativeApp&quot;,\n&quot;rememberSelection&quot;: false,\n&quot;requestCache&quot;: &quot;default&quot;,\n&quot;requestCacheCss&quot;: true,\n&quot;requestCacheImage&quot;: true,\n&quot;requestCacheWebFont&quot;: false,\n&quot;requestCredentials&quot;: &quot;same-origin&quot;,\n&quot;requestMaxTries&quot;: 3,\n&quot;requestReferrerPolicy&quot;: &quot;strict-origin-when-cross-origin&quot;,\n&quot;requestTimeout&quot;: 300,\n&quot;rootFolder&quot;: &quot;maoxian摘录&quot;,\n&quot;saveDomainAsTag&quot;: false,\n&quot;saveFormat&quot;: &quot;md&quot;,\n&quot;saveInfoFile&quot;: false,\n&quot;saveTitleFile&quot;: false,\n&quot;selectSaveFormatOnMenus&quot;: false,\n&quot;shortcutSlot0&quot;: &quot;_openLastClipping&quot;,\n&quot;shortcutSlot1&quot;: &quot;_clipAsDefault&quot;,\n&quot;shortcutSlot2&quot;: &quot;_clipAsHTML&quot;,\n&quot;shortcutSlot3&quot;: &quot;_clipAsMarkdown&quot;,\n&quot;shortcutSlot4&quot;: &quot;_doNothing&quot;,\n&quot;shortcutSlot5&quot;: &quot;_doNothing&quot;,\n&quot;shortcutSlot6&quot;: &quot;_doNothing&quot;,\n&quot;shortcutSlot7&quot;: &quot;_doNothing&quot;,\n&quot;shortcutSlot8&quot;: &quot;_doNothing&quot;,\n&quot;shortcutSlot9&quot;: &quot;_doNothing&quot;,\n&quot;titleFileFolder&quot;: &quot;$CLIPPING-PATH&quot;,\n&quot;titleFileName&quot;: &quot;a-title_$TITLE&quot;,\n&quot;userCommandsText&quot;: &quot;{\\n \\&quot;doNothing\\&quot;: {\\&quot;exec\\&quot;: \\&quot;doNothing\\&quot;}\\n}&quot;,\n&quot;version&quot;: &quot;2.16&quot;\n},\n&quot;history.page.cache.enableAdvancedSearchMode&quot;: false,\n&quot;history.page.cache.enableConfirmMode&quot;: true,\n&quot;history.page.cache.localstorage.migrated&quot;: true,\n&quot;history.page.cache.search.keyword&quot;: &quot;&quot;\n},\n&quot;backupAt&quot;: &quot;2024-12-17 16:25:24&quot;\n}",
		"tags": [ "note","obsidian","网页剪藏"]
},

{
		"title": "Obsidian插件测评——BetterPluginsManager：插件分组、标签管理，插件备注，延迟启动",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Obsidian插件测评/Obsidian插件测评-BetterPluginsManager-插件分组、标签管理，插件备注，延迟启动/",
		"content": "插件简介\nBetter Plugins Manager (BPM)是一款 Obsidian 插件管理工具，功能包括：插件分组、标签管理、备注和延迟启动，提升插件管理效率和用户体验。\n使用示例\n插件分组&amp;延迟启动\n\n标签管理\n\n插件备注\n\n项目情况\n是否上架官方市场：✅️\n项目地址链接\n使用教程\n在OB插件市场中搜索安装，然后点击OB左侧的 图标即可启动管理页面。\n在管理页面里可以完成以下工作：\n\n设置分组\n分配标签\n自定义插件名称与描述\n设置插件的启动延迟时间\n筛选插件：支持按分组、标签、名称筛选\n\n管理页面各部件使用说明请参照下图：\n\n因为插件的操作逻辑很简单，没必要再把图中的说明复述一遍，不过我要强调几个重点：\n\n首次使用此插件时，建议复制当前库，以便在副本中测试插件功能，确保无误后再在主力库中启用（或者说首次使用任何插件时，都推荐这样做）\n使用本插件管理 Obsidian 插件后，请避免使用 Obsidian 自带的插件管理器开关插件，以免引发未知错误\n一键开关功能仅针对当前视图中的插件生效。通过分组或标签筛选，可以批量开关特定插件（也就是说如果你没有开启任何筛选功能的话，一键开关插件就是把你的OB中的所有插件一键开关，目前0.0.4版本的插件描述有误，请以本文为准）。\n\n如果需要调整分组、标签和延迟，则需要前往BPM的设置页面中添加。（可选）点击取色工具来自定义元素的颜色，然后输入id（推荐使用纯英文）和名称，点击加号即可添加。\n\n添加分组：\n\n添加标签：\n\n添加延迟：\n\n闲谈\n有一段时间我一直想优化我的Obsidian启动速度，一个常用的方案就是让一部分插件在Obsidian启动后再启动。于是我尝试了很多方案，一开始我使用templater脚本来实现插件延迟启动，但是这种方案依赖于代码，不方便随时修改，然后我使用了 PluginGroups 和 LazyPlugins，前者已经停更两年，并且分组操作窗口小而不直观，后者专注于插件的延迟启动，但在我使用的时候有奇怪的bug。\n直到我朋友02开发了这款插件，几乎能满足我的所有需求。直观的插件分类管理，可视化的操作，多组别延迟启动。因此我想把它推荐给你们。",
		"tags": [ "note","obsidian插件"]
},

{
		"title": "Obsidian插件测评——i18n：汉化插件、翻译词典编辑器、云端共享词典、内置沉浸式翻译",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Obsidian插件测评/Obsidian插件测评-i18n-汉化插件、翻译词典编辑器、云端共享词典、内置沉浸式翻译/",
		"content": "插件简介\ni18n 是一款用于翻译 Obsidian 插件的插件，入门用户可以一键下载其他用户分享的成品词典，进阶用户可以使用内置编辑器翻译插件，支持百度翻译与 ChatGPT ，同时也内置了沉浸式翻译用于应急，最后用户可以选择分享自己的词典，插件内置了贡献用户榜单，截止 2025 年 01 月 10 日，已翻译了近 300 款插件。\n\n使用示例\n词典管理面板\n在这里可以提取、下载、注入或还原词典。\n\n译文编辑器\n在这里可以自由编辑词典。\n\n译文审核面板\n云端的插件都是由热心志愿者无偿维护的，每个词典均经过审核，保证新手可以开箱即用。\n\n沉浸式翻译\n如果某个插件还没有云端词典，也可以使用沉浸式翻译来机翻。\n\n项目情况\n是否上架官方市场：❌️\n项目地址链接\n使用教程\n概念定义\n这个部分我会讲解 i18n 名称的来历、它的翻译工作原理，如果只是想使用成品词典的朋友可以跳过本章。如果你不了解编程，但是想深度使用这个插件，我建议你阅读。\n名称含义\ni18n 是 internationalization 的缩写，意为“国际化”。为了避免概念混淆，本文中提到的 i18n（除特别说明外）均指代该插件。\n插件翻译原理\n一个 Obsidian 插件一般由三个文件：main.js、manifest.json、style.css 组成。\n它们的职责为：\n\nmain.js：插件的本体，所有插件的功能实现与文字都存放在此\nmanifest.json：插件的描述信息，如 id、名称、简介和版本号等信息都存放于此\nstyle.css：插件的样式，即控制其外观的代码\n\n也就是说，插件显示在用户界面的所有文字信息通常存放于 main.js 文件中。最基础的翻译方法是直接定位到对应文字，然后将其替换为翻译后的内容。\n但是最正统、优雅的翻译方式应该是在插件开发阶段，开发者把所有需要显示给用户的文字都设置为“变量”，然后再从语言文件中获取这个“变量”的值，这样只需要翻译这个语言文件即可。这是标准的软件翻译方法。\n但是 Obsidian 插件开发是由个人兴趣驱动的，不是所有的开发者都有意愿为自己的插件添加这样的功能。因此有的人会使用原始方法进行翻译，而 i18n 就是一款以 Obsidian 插件形式来完成原始方法的插件，它的原理很简单，就是查找并替换文本。不过它提供了一套工作流来完成查找、翻译、替换、分享、审核。\ni18n 工作原理\n提取\n这里我们将所有会被用户看到的文本称为“UI 文本”，i18n 会使用正则提取 main.js 中常见的 UI 文本，并且将其存放到待翻译插件目录下的 lang 目录中的 zh-cn.json 文件中（文件名由目标语言决定），这个时候我们只能得到一个由类似 apple:apple 的文本组成的文件，我将其称为“词典”，这个时候它只说明我们有一个英文 UI 文本叫 apple。前面的 apple 是原文，而后面 apple 所在就是译文的位置。（其实在 json 文件中，前面那个叫做“键（key）”，后面那个叫做“值（value）”）\n翻译\n在上一步我们得到了一个待翻译的词典，这一步我们需要翻译这个词典。也就是说我们要把第二个 apple 翻译为 苹果，把一个词典中所有的“值”都翻译完之后，一个成品词典就诞生了，这个时候所有的“值”的集合就可以被称为译文，但是如何在全过程中称呼这个文件呢？用译文去指代一个刚刚被提取的文件似乎不严谨，因此我们就用“词典”来称呼它吧。\n为了方便翻译，i18n 也提供了机器翻译接口，包括百度翻译与兼容 OpenAI 格式的大语言模型接口。其中百度翻译 api 每个人都能申请到免费的，而兼容 OpenAI 格式则能让用户使用几乎所有的大语言模型 AI。\n注入/替换\n当我们完成翻译后，原插件没有发生变化，我们需要根据“键”与“值”的关系，用我们翻译好的内容一一替换原文，这个过程被我称之为“注入”，i18n 中对应的按钮名称为“替换”。\n云端\n虽然我们已经尽可能的简化了翻译流程，但是依然需要用户具备一定的动手能力，因此我们设计了云端词典库，我们借用 Gitee 的 issue 区作为中转区，把用户提交的词典放到中转区，再由志愿者管理员手动检查词典是否有原则性错误（宥于精力、水平有限，只审核明显错误，不能控制翻译质量），审核通过后词典会被存放到 i18n 插件开源库中，新手用户可以在插件中下载对应插件的词典。我们对云端词库的预期只是“满足小白用户的、开箱即用的”，因此不要对它抱有过高期望，下载的词典也可以被二次编辑。\n新手入门：安装插件、下载云端词典并注入\n插件安装方法一：Gitee 手动下载安装\n打开项目地址： zero/obsidian-i18n-translation ，点击发行版下蓝色的版本号\n\n下载 main.js、manifest.json、style.css 这三个文件\n\n再把文件复制到 Obsidian 库内的隐藏文件夹中，路径为 Obsidian库文件夹/.obsidian/plugins/i18n\n\n注：也可以使用 brat 安装，GitHub 有同步的仓库，此方法不再赘述。\n插件安装方法二：使用 pkmer 插件市场\n详见 PKMer_Obsidian 插件：PKMer 不需要魔法，完美解决 Obsidian 无法加载第三方插件\n安装 pkmer 之后，搜索 i18n 即可安装。\n下载云端词典并注入\n\n打开 i18n 设置，确认云端模式已打开\n点击 Obsidian 左侧的 i18n 图标\n如果本地不存在词典，且对应插件云端已有分享词典，你会在插件后面看到一个 下载 按钮，如果云端没有词典，则没有下载按钮\n\n注：如果本地已有词典，下载 按钮也不会出现，需要删除本地词典\n\n点击 下载 按钮后，会出现下载面板，点击 保存 按钮即可\n保存完成后，提取 按钮会变成 替换 按钮，点击 替换 后对应插件就会被翻译，如果依然插件界面未翻译，则需要重启 Obsidian\n\n特殊情况：如何翻译 Style Settings 插件中的其他主题/插件\n常常有人提问：“为什么我注入了 Style Settings 插件的词典，里面内容依然是英文？”，因为这是一个特殊情况。\n原理解析：Style Settings 插件中显示的其他插件设置，自然不可能是 Style Settings 自身携带的，如果只是翻译 Style Settings 插件的 main.js，里面的设置不会有任何变化，因为这些文本是其他插件作者在开发插件时根据 Style Settings 的规范，放在对应插件的 style.css 中，因此我们真正需要翻译的是对应插件的 style.css 文件。\n下面讲解一下如何翻译某个插件/主题在 Style Settings 插件中的设置项：\n\n点击 i18n 控制面板右上角的调色板符号\n在这个 Style Settings 专属面板中按照普通插件的翻译流程操作即可\n\n没有云端词典？使用沉浸式翻译来应急\n如果某个插件没有对应的云端词典，该怎么办呢？ 为了解决这个问题，i18n 集成了知名浏览器插件 沉浸式翻译。\n使用方法也很简单：\n\n打开 i18n 设置页面，切换到 沉浸翻译\n点击 开启 按钮\n点击悬浮球使用沉浸式翻译，更多配置请参见沉浸式翻译的官方\n\n注意事项\n由于 i18n 仅简单集成了沉浸式翻译的 SDK，因此存在部分功能无法正常使用的情况，包括但不限于：\n\n无法打开沉浸式翻译的网页设置页面，只能使用悬浮球的设置页面\n\n因此无法配置自己的 api key\n\n如果设置了 永不翻译该网站，悬浮球会消失，无法通过开关设置调出，即便重装 i18n 插件也无法重新调出悬浮球\n\n如果在我的强调下，你还是点击了 永不翻译该网站 并且想再次调出悬浮球，可以在 Obsidian 的调试控制台里输入这段代码 [1]\n提取词典并翻译\n提取\n点击 提取 按钮即可\n\n注意事项：i18n 是通过正则表达式来匹配插件中的 UI 文本，但这种方法不是万能的。一般插件作者会使用形如 .setName(&quot;apple&quot;) 的函数 [2] ，因此我们可以用正则来匹配这个函数，其他同理。但是这种方法有几个缺陷：\n\nObsidian 官方并没有规定 UI 文本的写法，因此有无限种写法，每种写法都要写一个正则匹配，因此总有未考虑的情况\n匹配到的函数括号中可能会嵌套函数，因此不能简单的把括号内的文字全部翻译\n部分作者会采用非通用的 UI 文本编写方式，无法匹配\n\n手动翻译\n编辑器打开按钮：\n编辑器：\n\n注意事项：\n\n编辑完成后一定要保存\n正则匹配可能会产生很多不需要翻译的内容，如果你要上传到云端，请删除这些内容\n内置匹配的正则规则有限，如果还有没匹配到的，请打开对应的 main.js 搜索文本（可以直接点编辑器内的 源码 按钮一键打开）\n\n推荐使用 vscode 来打开，它的搜索功能很好用\n只需要保证搜索到的文本是唯一的（不唯一就多复制一点前后内容），就可以把这段文本复制到新建框，再点击 新建 按钮\n\n翻译的时候要避免翻译变量、函数等内容。例如原文为：&quot;.createEl(\\&quot;h1\\&quot;, {\\n text: \\&quot;Delete the file and its all attachments - logs \\&quot;\\n })&quot;， 译文可能被翻译为：&quot;.创造El(\\&quot;h1\\&quot;, {\\n 文本: \\&quot;删除文件及其所有附件 - 日志\\&quot;\\n })&quot;，但此处的 .createEl 和 text 不该被翻译。\n\n机器翻译\n声明：\n\n这个机器翻译功能挺烂的，建议先用一个简单插件练手，如果能接受它，再投入实际使用\n机器翻译可能导致词典错误：因为待翻译的内容可能包含函数名与变量，而机器翻译无法准确的区分它们，从而导致翻译错误，因此需要人工检查机器翻译得到的词典，所以强烈建议只把机器翻译作为一项不成熟的辅助手段\n机器翻译可能会卡住：如果词典过大，机器翻译需要很长时间，在过程中如果触发了 api 的频率限制，可能会导致翻译失败，因此不建议翻译过多条目的词典（如 pdf++ 这种重量级插件）\n目前机器翻译只支持未提取的插件，即机器翻译包括 提取 与 翻译（其实这一点不合理，但是忘了改……）\n\n步骤：\n\n配置接口（二选一即可）：\n\n百度接口\nOpenAI 接口\n确保插件未提取词典，点击 AI 按钮即可开始机器翻译\n\n提交词典至云端\n\n确保已开启 共建云端 中的 贡献者模式，如果不执行第 2 步，则使用集体账号署名\n（可选）如果你拥有 Gitee 账号，想保留自己的署名，同时也让自己的账号成为 i18n 的贡献者，则可以申请一个 Gitee 的个人令牌，确保个人令牌具有 issue 的权限即可，再将个人令牌填入云端模式设置中的贡献者模式中\n确保自己已经完成了一份词典，以下是对词典的要求：\n\n上传之前自己要先注入使用，确保插件不会因为词典崩溃，这一点非常重要\n如果云端已有词典，应该在原有基础上修改\n删除所有未翻译的词条\n不改变原文的含义\n不翻译插件名称\n尽量不翻译特定术语，如 dataviewjs 作为插件 dataview 的延伸，最好保留原文\n\n确保无误后点击 共享译文 按钮并根据提示确认\n等待插件提交，若成功提交，则会打开一个 Gitee issue 网页，管理员会尽快审核词典。（注：issue 中就是被压缩的词典，如果你需要在外部条件下解码，可以使用网页工具 [3] 。若词典有存在问题，可能会被拒绝，因此如果你希望获得相关反馈，建议按照第 2 步配置个人令牌，这样 Gitee 会有提醒。）\n\n常见问题\n\n手机/平板无法使用：插件不支持移动端，但是被翻译的插件复制到移动端可以继续使用\n没有下载按钮\n\n原因有二：\n\n没有打开云端模式\n本地存在词典（常见于新手下载后盲目堤点击了 提取 按钮）\n\n插件列表为空/显示插件数量少于实际数量：本地存在格式错误的词典，比如 zh-cn.json 中缺少了一个逗号\n注入词典后插件依然为原文：重启 OB 即可\n插件更新后翻译失效：正常现象，因为翻译原理就是替换了插件文件，更新后新的文件会覆盖掉已翻译的文件，重新注入即可。也可以在 i18n 中打开【本地模式】中的【智能更新】功能\n插件前面有一个 已过期 标签/更新按钮点了时候还在：i18n 插件开发不完善的问题，不需要在意\n\n闲谈\n其实我也算是 i18n 的开发者之一（只做了一点小小的工作，绝大部分工作由 02 完成）。虽然我本人可以接受英文界面，但是还是觉得用中文界面更容易进入心流，但苦于社区中没有优雅的插件翻译方法（那个时候基本都是大家手动翻译再分享翻译后的插件，导致汉化后的插件与市场内的插件分道扬镳），于是在半年前突然萌生了自己制作一款 Obsidian 插件来完成对其他插件的翻译。当时的我也意识到，采用修改源代码的方式来翻译插件的方式有诸多问题，因此我一开始就放弃这个思路，而是采用修改 DOM 元素的方法，但紧接着就陷入了困境，在查找资料的过程中，我在 Obsidian 中文论坛看到了 02 的帖子，惊讶于原来有人也在做类似的工作，虽然他选择了另一条道路，但是他已经做出了一个具有相当成熟度的作品，于是我联系上他，和他开始了无数次的讨论与修改。\n在这款插件发展的过程中，我们也一直在说“i18n 是一款充满了妥协的插件”，从它不优雅的实现方式，再到被 Obsidian 官方拒绝上架，到因为如何实现云端词库的审核与存储而重构了三次代码，再到被其他插件作者要求下架他的插件翻译。这绝对不是一条坦途。\n不优雅但是有用，但是被官方拒绝上架甚至被插件作者要求删除译文\n在“插件翻译原理”那章我已经提到了优雅的软件翻译方式，i18n 的实现方式无疑是不优雅的，直接替换源代码可能会引入未知的错误。我曾经在英文社区和 Obsidian 的官方人员 joethei[4] 以及几位优质插件的开发人员聊过此事 [5] ，他们表示不可能接受修改插件源代码来实现翻译的方式。翻译只应该通过开发者提供的 i18n 框架实现（此处的 i18n 指国际化）。\n我表示理解，因为他们这是典型的程序员专业视角，他们说的没有任何错。但是期望插件开发者都有自觉去添加 i18n 框架是不现实，因为绝大部分插件开发都始于兴趣，终于热情熄灭，Obsidian 社区已经积累了 2000 余个插件，绝大部分插件没有提供 i18n 框架，现在没有，未来也不会有。\n当然“典型的程序员”这个时候会说，插件是开源的，想翻译就自己去提 PR。但是这就给翻译人员提出了更高的要求：\n\n有翻译插件的热情\n能完成翻译工作\n具备一定的代码能力，会使用 GitHub 的 PR 协作功能\n插件原作者愿意审查的代码（不少几年不更新的插件，堆积着很多 issue，恐怕作者连账号都没有登录过）\n每次更新译文，都要重复步骤 1-4\n\n经过分析，可以说在这样的困境下，除了处于生态位头部的插件，其他插件只能随缘地获得国际化支持。\n我也给官方提了建议——官方提供接口，要求所有 UI 文本都采用统一方式来渲染，或者要求插件作者必须引入 i18n 框架，同样的建议我也在网上看到别人提过 [6] ，但是 joethei 给出的回复是他们可能会提供一些辅助函数，但是不会强制要求。\n可以说期待官方在国际化上有所作为是彻底落空了。当然我并非在此指责 Obsidian 官方，我完全能理解他们的选择，Obsidian 的商业方式注定他们只能采用小团队规模，因此国际化这种优先级更低的工作被搁置是很正常的。\n因为翻译插件和二次开发插件不同，翻译的插件作者署名依然是原作者，因此我们也担心会有人因为 i18n 翻译导致插件出错而去插件项目下报错，我们在插件运行前的用户协议中进行了严肃声明。即便如此，当我在 discord 发起了那场讨论后，tasks 插件的作者还是跑到插件项目地址下要求删除他的插件的译文 [7]。这个事让我挺无语的，不过最后的发展还是好的，如果想吃瓜的可以去看原贴，此处就不再赘述。\n插件翻译的难点\n因为插件的 UI 文本不像一本小说有着清晰足够的上下文，加上插件作者的表达能力参差不齐，很多时候只有一个深入使用过此插件的用户才能做出足够好的翻译，因此我们希望通过互通有无来让大家都能用上优质的翻译，刚开始的时候为了快速填充云端词典，我制作了不少粗劣的机翻词典，但是随着大家的加入，词典的质量也越来越好。最后我也能用上别人分享的优质词典，这也是开源社区的魅力。\n云端词库建立的难点\n为了确保云端词库是社区持有，如果未来开发者弃坑也能继续发展，我俩决定用 GitHub 作为存储库，但在云端词库的审核机制上，我们纠结了很久。\n有两种方案：\n\n由管理员审核，每个插件的每个版本只保留一份，以确保词典的质量\n所有人都可以自由上传，通过用户的评分来对词典进行排名\n\n方案\n优点\n缺点\n\n管理员审核\n开箱即用，新手友好\n审核过程质量无法控制；未来社区枯竭后，云端难以为继\n\n自由上传\n无需审核降低人工成本；未来可持续\n可能存在大量无效、低质量词典，用户体验差\n\n我俩讨论了很多，最后还是想尽可能的照顾新手的体验，如果采用自由上传的方式，恐怕会让新手很晕。而后面我审核的时候拒绝了几百个无用词典的经历也证明了，如果开放自由上传，维护成本也不会小。\n目前采用 Gitee 作为云端词库，无法对单条翻译进行评论审核，同时用户发现某个翻译有改善空间也无法轻易提交建议，因此我曾经考虑过把云端词库的协作方式改为使用 crowdin 之类的 i18n 工具，都开始重构代码了，才发现存在一些系统性问题：crowdin 这类工具也是为了“优雅的翻译”而设计的，因此它们要求要有一个包含所有待译原文的词典，也就是说使用这类工具，不需要考虑“翻译的原文”从何而来，因为这本身就是软件作者应该提供的。而 Obsidian 插件根本没有这个东西，我们的原文都是译者逆向源代码找到的，而 crowdin 不提供上传原文的方法，只能项目管理员手动上传。这无法满足我们对审核权限划分的要求，因为如果每个人都能上传，就意味着每个人都要有管理员的权限，并且这个过程没有 api，还必须使用网页端。\n但这真的让我感到很遗憾，如果未来我能解决这个问题，我会考虑重构 i18n，依然采用 crowdin 的方案，因为这种方案能让任何能使用翻译软件的人就能参与到插件翻译中来。\n\nconst clearImmersiveTranslate = async () =&gt; {\nconsole.log('开始清理 Immersive Translate 相关数据...');\n\n// 1. 清理 localStorage\nconst patterns = [\n'immersive',\n'translate',\n'userLanguage',\n'targetLanguage',\n'sourceLanguage',\n'neverTranslate',\n'alwaysTranslate',\n'translationService',\n'openai',\n'deepl',\n'google',\n'microsoft',\n'preferences',\n'config',\n'cache',\n'settings'\n];\n\nconst keysToRemove = Object.keys(localStorage).filter(key =&gt;\npatterns.some(pattern =&gt; key.toLowerCase().includes(pattern.toLowerCase()))\n);\n\nconsole.log('找到需要清除的存储项：', keysToRemove);\nkeysToRemove.forEach(key =&gt; {\nlocalStorage.removeItem(key);\nconsole.log('已清除 localStorage 项:', key);\n});\n\n// 2. 清理 window 对象上的配置\nconst windowKeysToDelete = Object.keys(window).filter(key =&gt;\nkey.toLowerCase().includes('immersive') ||\nkey.toLowerCase().includes('translate')\n);\n\nwindowKeysToDelete.forEach(key =&gt; {\ndelete window[key];\nconsole.log('已清除 window 属性:', key);\n});\n\n// 3. 清理 DOM 元素\nconst elementsToRemove = [\n'#immersive-translate-popup',\n'.imt-script',\n'[data-id*=&quot;immersive-translate&quot;]',\n'[class*=&quot;immersive-translate&quot;]',\n'[id*=&quot;immersive-translate&quot;]',\n'script[src*=&quot;immersive-translate&quot;]',\n'link[href*=&quot;immersive-translate&quot;]'\n];\n\nelementsToRemove.forEach(selector =&gt; {\ndocument.querySelectorAll(selector).forEach(el =&gt; {\nel.remove();\nconsole.log('已移除 DOM 元素:', selector);\n});\n});\n\n// 4. 清理 IndexedDB（如果有）\ntry {\nconst databases = await window.indexedDB.databases();\nconst dbsToDelete = databases.filter(db =&gt;\ndb.name &amp;&amp; (\ndb.name.includes('immersive') ||\ndb.name.includes('translate')\n)\n);\n\nfor (const db of dbsToDelete) {\nif (db.name) {\nwindow.indexedDB.deleteDatabase(db.name);\nconsole.log('已删除数据库:', db.name);\n}\n}\n} catch (error) {\nconsole.log('清理 IndexedDB 时出错:', error);\n}\n\n// 5. 重置配置\nwindow.immersiveTranslateConfig = {\npageRule: {\nselectors: ['.markdown-reading-view *'],\nexcludeSelectors: ['.markdown-reading-view .cm-inline-code']\n},\nanalyticsConfig: {\nenabled: false\n},\ntranslationService: 'google',\ngeneralRule: {\nautoShow: true,\nalwaysShowIcons: true,\ninstantTranslate: true\n},\ntranslationTheme: 'none',\ntranslationLanguagePattern: {\nmatches: ['**/*']\n}\n};\n\nconsole.log('已重置基本配置');\n\n// 6. 重新加载翻译脚本\nconst script = document.createElement('script');script.classList.add('imt-script');script.async = true;\nscript.src = 'https://immersive-translate.owenyoung.com/immersive-translate.js';\nscript.onload = () =&gt; {\nconsole.log('翻译脚本重新加载成功');\n};\nscript.onerror = (error) =&gt; {\nconsole.error('翻译脚本加载失败:', error);\n};\ndocument.body.appendChild(script);\n\nconsole.log('清理完成，准备重新加载页面...');\n\n// 7. 延迟重新加载页面\nreturn new Promise(resolve =&gt; {\nsetTimeout(() =&gt; {\nconsole.log('即将重新加载页面...');\nresolve();\n}, 1000);\n});\n};\n\n// 执行清理\n(async () =&gt; {\ntry {\nawait clearImmersiveTranslate();\nwindow.location.reload();\n} catch (error) {\nconsole.error('清理过程中出错:', error);\n}\n})();\n\n这是重新调出悬浮球的代码。 ↩︎\n\n函数是不严谨的说法。 ↩︎\n\nZlib Decompress Online to Zlib Decode Text ↩︎\n\njoethei 负责插件审查和开发生态系统，据我观察，几乎所有插件都由他审核。 ↩︎\n\n如果想查看此事的详细记录，可以查看 关于这个插件无法上架的解释以及与官方人员的讨论记录obsidian-i18n · Discussion #19 ↩︎\n\n允许用户翻译插件 - 功能存档 - Obsidian Forum --- Allow users to translate plugins - Feature archive - Obsidian Forum ↩︎\n\nRemove all translations for obsidian-tasks-plugin - 删除所有 obsidian-tasks-plugin 的翻译文件。 · Issue #18 ↩︎",
		"tags": ["19", "18", "note","obsidian插件"]
},

{
		"title": "Obsidian轻量级PPT教程",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Obsidian轻量级PPT教程/",
		"content": "前言\n不论是学习还是工作，我们总有需要展示内容的时候，一般会用幻灯片 [1] 来完成。PPT 相较于传统文稿，可以更直观地将信息传递给观众，通过图文结合的方式展现内容，同时利用动画效果引导视线，减轻演讲者的压力。\n随着我们在 Obsidian（后文简称 ob）笔记系统中的应用日渐深入，用 ob 制作 PPT 的需求变得自然而然。本文将介绍几种在 ob 中制作 PPT 的常见方式，包括 ob 自带的幻灯片与白板核心插件，以及第三方插件 Slides Extend、Advanced Canvas 和 Excalidraw。\n当然，Obsidian 在制作 PPT 领域无法与专业软件相提并论，因此建议大家结合自己的实际需求和 Obsidian 的功能限制，选择最适合的方式进行尝试。\n本文配套示例库：Release Obsidian轻量级PPT教程配套示例库 · dangehub/aqu_ob_share\n本文配套视频：如何炫酷的展示你的笔记 —— Obsidian PPT 的三种方法_哔哩哔哩_bilibili\n核心插件：幻灯片\n相关资料\n\n官方文档：幻灯片 - Obsidian 中文帮助 - Obsidian Publish\n\n使用教程\nOb 提供了一个原生的幻灯片核心插件。启用插件后，可以右键任意文件选择 开始演示，或按下快捷键 Ctrl+P 输入命令 幻灯片：开始演示 来激活模式。\n在演示模式下，当前文档会以幻灯片形式播放，并以 --- 分隔符将文档内容划分为多页。通过键盘左右箭头可以控制翻页。\n优点/推荐使用场景\n\n完美支持 Ob 的所有语法\n对已有笔记的改动最小，能快速将笔记转换为演示内容\n\n缺点/局限性分析\n\n功能简单，缺少动画等高级功能\n单页内容超出限制时，额外内容会被直接截断，无法滚动查看\n\n第三方插件：slides extend\nSlides Extend 插件 [2] 是 Ob 原生幻灯片插件的功能扩展版本，由 Reveal.js 提供支持。\n相关资料\n\n项目开源地址：ebullient/obsidian-slides-extended\n项目文档：见 GitHub 仓库的 docs 目录（ps：吐槽一下 readme 里也不放链接，需要自己找）\n此插件由 Reveal.js 驱动，因此可以参考 Reveal.js 的文档：The HTML presentation framework | reveal.js\n\n使用教程\n\n基本的操作逻辑与核心插件幻灯片一致，--- 作为分页符\n支持动画，参考文档：自动动画 | Reveal.js --- Auto-Animate | reveal.js\n支持嵌入 Excalidraw 图形，需开启 Excalidraw 的自动导出功能或通过 Frontmatter 配置\n\n其中为了支持 excalidraw 嵌入，需要让 excalidraw 自动生成对应的图片，并且编辑后自动修改图片，下面设置二选一：\n\n打开【嵌入到 Markdown 文档中的绘图】— 【导出】— 【导出设置】— 【自动导出 SVG 副本】或【自动导出 PNG 副本】\n把 excalidraw 文件以 md 视图打开（编辑器右上角三个点或者命令搜索”excalidraw 切换“），手动添加 frontmatter excalidraw-autoexport:svg （值也可以设置为 png/both），这种方法只会让被设置的文件自动生成对应图片。\n\n优点/推荐使用场景\n\n代码编辑与 Ob 的笔记系统无缝衔接，可快速将笔记转换为 PPT\n易于实现自动化流程，例如针对固定格式的笔记（如日记）自动生成 PPT\n内置 web 服务器，可用浏览器播放 PPT\n\n缺点/局限性分析\n\n缺少可视化界面，学习成本较高\n编辑过程中容易因代码错误导致演示失效\n\n核心插件：白板 + 第三方插件 advanced canvas\nOb 自带的白板插件虽无演示功能，但可通过 Advanced Canvas 插件实现扩展。这种方法尤其适合以白板形式记录笔记的场景，如头脑风暴或碎片知识整理，能帮助理清分散的思路\n相关资料\n\n白板的官方文档：白板 - Obsidian 中文帮助 - Obsidian Publish\nadvanced canvas 项目开源地址：Developer-Mike/obsidian-advanced-canvas\n\n使用教程\n安装好 advanced canvas 插件，无需任何配置，在 ob 里新建一个白板文件，然后在正下方能看到在原有白板的基础上多出来两个按钮，点击或拖拽 Drag to add slide 按钮即可新增 PPT 分页区域。\n每一个区域就是一页 PPT，第一次创建的 PPT 分页就是整个 PPT 的封面，右上角有一个 start 标识。\n\n在创建了 PPT 分页后，按 ctrl+p 输入命令 Advanced Canvas:Start presentation 即可开始 PPT 展示。\n这种方式制作的 PPT 的展示顺序由 PPT 分页的箭头控制，如果只是添加了多个分页，但是没有使用箭头将 PPT 分页连接起来，播放时则只展示 start 分页。\n可以通过箭头实现 PPT 的复杂跳转逻辑，比如 1--&gt;2--&gt;3--&gt;2--&gt;4--&gt;5，但需要注意，start 分页只能连接一个后续节点，如果连接多个，则只有第一个连接的分页会被识别。\n优点/推荐使用场景\n\n充分利用 Ob 原生白板功能，可直接嵌入笔记内容\n制作过程中白板的布局即完成了排版，减少了 PPT 制作的额外工作量\n通过箭头控制分页跳转逻辑，轻松实现复杂的 PPT 演示路径\n\n缺点/局限性分析\n\n如果原笔记以文字为主，需手动将内容转换为白板形式，工作量较大\n动画效果有限，仅支持页面切换\n\n第三方插件：excalidraw\n相关资料\n\n项目开源地址：zsviczian/obsidian-excalidraw-plugin: A plugin to edit and view Excalidraw drawings in Obsidian\n项目文档：欢迎 - Excalidraw --- Welcome - Excalidraw （建设中）\n（强烈推荐）PKMer_Excalidraw 脚本：Slideshow 完美实现画板幻灯片演示的脚本\n\n使用教程\n具体教程见 pkmer 文章：PKMer_Excalidraw 脚本：Slideshow 完美实现画板幻灯片演示的脚本\n需要先在 excalidraw 的脚本库中安装 slideshow 脚本，然后可以通过箭头和 frames 的编号来控制幻灯片顺序。\n优点/推荐使用场景\n\nexcalidraw 有着 ob 里最强的画图能力，用它来做 PPT，内容丰富的上限极高\nframe 编号和箭头这两种方式来控制 PPT 的镜头运动，兼顾了简单出图与复杂运动轨迹的需求\n\n缺点/局限性分析\n\nexcalidraw 相对重量级，对设备性能要求更高\n同白板一样，都需要根据文字内容再创作，不能直接转换\n\n后话\n为什么坚持用 Ob 做 PPT？最初是因为工作电脑性能较低，且由于网络限制，难以使用现代化工具。相比老旧的 Office，Ob 简洁的风格反而更适合理工科的表达需求。此外，我日常习惯用 Ob 写工作笔记，用它制作 PPT 显得顺理成章。\n当然，用 Ob 制作 PPT 需要量力而行，明确目标。如果只是单纯追求好看效果，专业软件仍然是不二之选。若只是为了“玩”或者“炫技”，这套方法也有相当高的上限，世界也需要更多“无意义”的探索。\n\n严格意义上“PPT”指代的是微软公司的 PowerPoint 软件，而“幻灯片”才是这种方式的名称，但是由于 PowerPoint 其广泛使用，所以人们把“幻灯片”与“PPT”划上了等号。因为本文中会频繁出现 obsidian 软件自带的幻灯片插件，为了避免混淆二者，因此本文以“PPT” 指代严格意义上的“幻灯片”，而用“幻灯片”指代 obsidian 中的幻灯片插件。 ↩︎\n\n这个项目继承自 advanced slides 插件，原插件作者表示在盈利路径上和 ob 官方有矛盾，做插件赚不到钱，导致他决定停止发布插件的后续更新。 ↩︎",
		"tags": [ "note","obsidian","PPT技巧"]
},

{
		"title": "Thino与Mac软件popclip联动，实现系统级全局划词摘录",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/Thino与Mac软件popclip联动-实现系统级全局划词摘录/",
		"content": "简单介绍一下 popclip：\n\nPopClip 是一款 macOS 效率工具，选中文本后弹出快捷工具栏，支持复制、粘贴、搜索等操作，并可通过扩展插件实现翻译、格式化、笔记保存等功能。\n\npopclip 有一个插件可以把选中的文本发送到 Obsidian 中，如果是在浏览器中选中文本，还可以用 md 格式把标题与链接插入到笔记中，很适合摘录。\n\n但是原有插件不支持插入当前时间戳，也就是 thino 需要的那个 - 18:34 前缀，因此我修改了插件，并且提交了 PR，现在可以在插件市场下载\n使用方法：\n1.在 Obsidian 中安装 advanced url 插件，启用后无需任何设置\n2.在 popclip 中安装 黑曜石 - popclip扩展 --- Obsidian — PopClip Extensions 插件\n3.在 popclip 中设置库名称\n4.勾选 include timestamp",
		"tags": [ "note","obsidian","obsidian插件"]
},

{
		"title": "发散性思考与线性输出",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/一键把excalidraw的头脑风暴输出为线性文章/",
		"content": "发散性思考与线性输出\n我以前一直都是采用传统的笔记方法，从上往下写。\n这种线性似乎是理所应当、浑然天成的，但是人在想问题的时候又喜欢在草稿上写写画画，这个时候思维的组织方式却是非线性的。\n接近的概念就是头脑风暴之类的思考组织方式，无意掉书袋，因此本文不再就此概念做过多讨论，我们姑且定义两种方式，不再深究其描述是否准确：\n\n从上往下的一维：线性\n上下左右都有：发散性\n\n这里就会引入一个问题，当你的大脑在发散性思考的时候，用线性的笔记辅助思考，就会出现脑子和手打架的窘境。\n举例来说：我在写某个主题的时候，会突然联想到一个分支想法，它不适合放进当前的正文，但是与之又有关联。如果是传统的笔记方法，这里可以使用便签（callout），但这样终究不太适合内容组织。因此类似 mindmap 的工具都会提供二维的内容输出方式。\n但是这会引入一个新问题——发散思考之后，如何输出高可读性的内容。\n不知道大家有没有这样的体验：自己做的思维导图再烂也能看懂，而别人做的再好也看得很晕。\n这就是非线性（发散性）内容的弊端，除非是自己生产（即已完成内化）的内容，否则非线性内容先天就更难理解。\n因此我们需要找到一个允许我们发散性思考，但是又能快捷的输出线性内容的的方法。\n线性输出脚本的前身\n当我产生了这个需求的时候，我先是尝试用 obsidian 的引用功能来实现它，因为 excalidraw 本身是支持对外提供内容的嵌入的。但是很难做到方便快捷。\n于是我在网上查询资料，了解到两位先驱者的探索：\n\nNote必利阀：从excalidraw视觉笔记到obsidian线性输出\n熊猫别熬夜：PKMer_自定义 Excalidraw 脚本 - 制作 Excalidraw 悬浮大纲以及一键生成线型笔记\n\n学习了两位网友关于 excalidraw 笔记如何实现线性输出的思考，其中\n\nNote 必利阀制作了一个脚本，可以把 excalidraw 中选中的文本和图像按编辑的时间顺序输出为文字与图像的引用，最终复制到剪贴板，我们只需要把这个粘贴到想要用的地方就行\n熊猫别熬夜制作了一套脚本，要求使用者在 excalidraw 编写好符合一定格式的标题，然后通过脚本把标题与对应的内容引用出来\n\n前者的优势是输出的内容为文字与图片链接，是可以被标准 md 识别的，但缺少了 excalidraw 的强大图形能力（因为它要求把 freedraw 转成图片，后续再编辑也是很麻烦的）。另外因为 excalidraw 的 Frame 和 Group 还不支持嵌套，所以如果有画中画这样的展现形式，则无法用后者的脚本实现。\n后者直接把 excalidraw 中的图形引用过来，能更好的保留 excalidraw 的功能，不过这样也导致如果有发布文章的需求，后续可能需要再手动去把 excalidraw 引用转换为图片。\n在学习两位的过程中，我厘清了 发散性思考 、线性输出 的概念，同时基于我自己的日记工作流，对熊猫别熬夜的脚本进行了修改，最终我的线性输出脚本诞生了。\n线性输出脚本\n脚本介绍\n本脚本的全名应该叫 excalidraw线性输出到同名笔记，它的功能也很简单，一言以蔽之：通过识别规定格式的文本，把与文本组合的内容以 excalidraw 的嵌入链接形式输出到对应笔记的指定标题下。\n如下图所示：\n\n本脚本通过识别形如 #1 标题 的文本，解析为 标题，并将该文本所属的组合（优先级分别为：Frame&gt;Group&gt;Element）引用链接插入到标题之后。\n脚本的优点：\n\n保留了 excalidraw 的图形能力\n将内容输出到指定文件并生成逐级标题，让思考输出的内容可以与文件本身融合，大纲可识别\n支持自定义在哪个标题后插入，并且会根据设置标题动态调整生成标题的层级（比如设置在 #灵感 后插入，则从二级标题开始生成，如果设置为 ##灵感，则会从三级标题开始生成，确保生成内容为子内容）\n\n脚本使用说明\n下载\n你可以在我的 Github 下载：dangehub/aqu_ob_share: Share my Obsidian techniques\n或者在文末直接复制源代码，自己新建一个 md 文件粘贴进去就好。\n安装使用\n\n把脚本放到 excalidraw 的 script 目录下\n前往 excalidraw 插件设置，在最后一项 已安装脚本设置 中修改 Custom Misc Header，设置为自己想要插入在哪个标题后，默认值 ## 1.3 杂记\n点击脚本按钮 or 使用命令工具\n文件 1.excalidraw 的线性内容会被输出到文件 1 中的 ## 1.3 杂记 标题下\n\n视频教程见：obsidian+excalidraw+线性输出脚本=快乐日记\n附脚本源代码\n[fold]\n// 鸣谢：本脚本在 `熊猫别熬夜` 网友的脚本上进行修改，并受到 `Note必利阀` 网友的启发\n\n// 更新日志\n\n// 2024-09-06 1.0版本发布，支持输出标题设置\n\n// 2024-09-08 1.0.1 新增嵌入画板宽度设置\n\n// 获取脚本设置\n\nlet settings = ea.getScriptSettings();\n\n// 设置默认值（如果是首次运行）\n\nif (!settings[&quot;Custom Misc Header&quot;] || !settings[&quot;Image Width&quot;]) {\n\n    settings = {\n\n        ...settings,  // 保留现有设置\n\n        &quot;Custom Misc Header&quot;: {\n\n            value: &quot;## 1.3 杂记&quot;,\n\n            description: &quot;自定义杂记标题，用于插入 Excalidraw 内容&quot;\n\n        },\n\n        &quot;Image Width&quot;: {\n\n            value: 10000,\n\n            description: &quot;设置嵌入画板的宽度，默认值保证画板最大&quot;\n\n        }\n\n    };\n\n    ea.setScriptSettings(settings);\n\n}\n\n// 使用设置中的自定义杂记标题和图片宽度\n\nconst customMiscHeader = settings[&quot;Custom Misc Header&quot;].value;\n\nconst imageWidth = settings[&quot;Image Width&quot;].value;\n\n// 计算customMiscHeader中的 #数量\n\nconst customHeaderLevel = (customMiscHeader.match(/^#+/) || [''])[0].length;\n\n// 获取笔记的基本路径和笔记名\n\nconst currentFile = app.workspace.getActiveFile();\n\nif (!currentFile) {\n\n    new Notice(&quot;❌ 无法获取当前文件&quot;, 3000);\n\n    return;\n\n}\n\n// 获取excalidraw文件路径、文件名，准备生成对应笔记\n\nconst filePath = currentFile.path;\n\nconst fileName = currentFile.name;\n\nconst fileBaseName = fileName.replace('.excalidraw', '');\n\n// 初始化变量\n\nlet frameIds = [];\n\nlet extrTexts = '';\n\n// 获取所有以'#'开头的文本元素（即标题）\n\nlet allEls = ea.getViewElements().filter(el =&gt; el.type === &quot;text&quot; &amp;&amp; el.text.startsWith('#'));\n\n// 对标题进行排序\n\nallEls.sort((a, b) =&gt; {\n\n    let aMatch = a.text.match(/^#([\\d.]+)/);\n\n    let bMatch = b.text.match(/^#([\\d.]+)/);\n\n    if (!aMatch || !bMatch) return 0;\n\n    let aParts = aMatch[1].split('.').map(Number);\n\n    let bParts = bMatch[1].split('.').map(Number);\n\n    for (let i = 0; i &lt; Math.max(aParts.length, bParts.length); i++) {\n\n        if (aParts[i] === undefined) return -1;\n\n        if (bParts[i] === undefined) return 1;\n\n        if (aParts[i] !== bParts[i]) return aParts[i] - bParts[i];\n\n    }\n\n    return 0;\n\n});\n\nfor (let i of allEls) {\n\n    let elText = i.rawText.trim(); // 使用 rawText 而不是 text，以规避换行符问题\n\n    let elID = i.id;\n\n    let match = elText.match(/^#([\\d.]+)\\s+(.*)/);\n\n    if (!match) continue;\n\n    let numberPart = match[1];\n\n    let titlePart = match[2];\n\n    // 计算标题级别\n\n    let levels = numberPart.split('.').length;\n\n    let headLevel = Math.min(levels + customHeaderLevel, 6);  // 根据customMiscHeader的级别调整\n\n    let heads = '#'.repeat(headLevel);\n\n    let titleText = &quot;&quot;;\n\n    let titleLink = &quot;&quot;;\n\n    let embedlinks = [];\n\n    let nums = 99;\n\n    // 处理excalidraw中的Frame、Group\n\n    if (i.frameId &amp;&amp; !frameIds.includes(i.frameId)) {\n\n        elID = i.frameId;\n\n        frameIds.push(elID);\n\n        titleLink = `${fileName}#^frame=${elID}`;\n\n        for (let j of ea.getViewElements().filter(el =&gt; el.type === &quot;embeddable&quot;)) {\n\n            if (j.frameId == elID) {\n\n                embedlinks.push(`\\n!${j.link} `)\n\n                let objectFrame = ea.getViewElements().filter(el =&gt; el.frameId === elID);\n\n                nums = objectFrame.length;\n\n            }\n\n        }\n\n    } else if (i.groupIds) {\n\n        titleLink = `${fileName}#^group=${elID}`;\n\n        for (let j of ea.getViewElements().filter(el =&gt; el.type === &quot;embeddable&quot;)) {\n\n            if (j.groupIds.some(groupId =&gt; i.groupIds.includes(groupId))) {\n\n                embedlinks.push(`\\n!${j.link} `)\n\n                let objectFrame = ea.getViewElements().filter(el =&gt; el.groupIds.some(groupId =&gt; i.groupIds.includes(groupId)));\n\n                nums = objectFrame.length;\n\n            }\n\n        }\n\n    } else {\n\n        titleLink = `${fileName}#^${elID}`;\n\n    }\n\n    // 生成标题文本\n\n    if (embedlinks.length &gt; 0) {\n\n        let extrEmbedlinks = embedlinks.join('\\r\\n');\n\n        titleText = `${heads} ${titlePart}\\n${extrEmbedlinks}\\n`;\n\n        if (nums &gt; 3) {\n\n            titleText += `!<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">${imageWidth}</a>\\n`;\n\n        }\n\n    } else {\n\n        titleText = `${heads} ${titlePart}\\n`;\n\n        if (nums &gt; 2) {\n\n            titleText += `!<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">${imageWidth}</a>\\n`;\n\n        }\n\n    }\n\n    extrTexts += titleText;\n\n}\n\n// 构建输出文件路径\n\nlet outputFileName = `${fileBaseName}.md`;\n\nlet outputPath = filePath.replace('.excalidraw', '');\n\n// 检查输出文件是否存在\n\nlet outputFile = app.vault.getAbstractFileByPath(outputPath);\n\nif (!outputFile) {\n\n    new Notice(`❌ 输出文件不存在：${outputPath}`, 3000);\n\n    // 尝试创建文件\n\n    try {\n\n        await app.vault.create(outputPath, '');\n\n        outputFile = app.vault.getAbstractFileByPath(outputPath);\n\n        new Notice(`✅ 已创建新文件：${outputPath}`, 2000);\n\n    } catch (error) {\n\n        new Notice(`❌ 无法创建文件：${outputPath}`, 3000);\n\n        return;\n\n    }\n\n}\n\n// 读取输出文件内容\n\nlet outputContent = await app.vault.read(outputFile);\n\n// 创建唯一标识符\n\nlet excalidrawIdentifier = `EXCALIDRAW_CONTENT_${fileName.replace(/[^a-zA-Z0-9]/g, &quot;_&quot;)}`;\n\n// 构建新的 Excalidraw 内容\n\nlet newExcalidrawContent = `&lt;!-- BEGIN ${excalidrawIdentifier} --&gt;\\n${extrTexts}\\n&lt;!-- END ${excalidrawIdentifier} --&gt;`;\n\n// 检查是否已存在 Excalidraw 内容\n\nlet startMarker = `&lt;!-- BEGIN ${excalidrawIdentifier} --&gt;`;\n\nlet endMarker = `&lt;!-- END ${excalidrawIdentifier} --&gt;`;\n\nlet startIndex = outputContent.indexOf(startMarker);\n\nlet endIndex = outputContent.indexOf(endMarker);\n\n// 辅助函数：获取标题级别\n\nfunction getHeaderLevel(header) {\n\n    return header.match(/^#+/)[0].length;\n\n}\n\n// 辅助函数：查找下一个相同或更高级别的标题\n\nfunction findNextHeader(content, startIndex, currentLevel) {\n\n    const headerRegex = /^#{1,6}\\s/gm;\n\n    headerRegex.lastIndex = startIndex;\n\n    let match;\n\n    while ((match = headerRegex.exec(content)) !== null) {\n\n        if (getHeaderLevel(match[0]) &lt;= currentLevel) {\n\n            return match.index;\n\n        }\n\n    }\n\n    return content.length;\n\n}\n\nif (startIndex !== -1 &amp;&amp; endIndex !== -1) {\n\n    // 如果存在，更新现有内容\n\n    outputContent = outputContent.substring(0, startIndex) +\n\n                    newExcalidrawContent +\n\n                    outputContent.substring(endIndex + endMarker.length);\n\n} else {\n\n    // 如果不存在，在自定义杂记标题后插入新内容\n\n    let miscIndex = outputContent.indexOf(customMiscHeader);\n\n    if (miscIndex !== -1) {\n\n        let currentHeaderLevel = getHeaderLevel(customMiscHeader);\n\n        // 找到下一个相同或更高级别的标题或文件末尾\n\n        let nextHeaderIndex = findNextHeader(outputContent, miscIndex + customMiscHeader.length, currentHeaderLevel);\n\n        // 在自定义杂记标题和下一个标题之间插入新内容\n\n        outputContent = outputContent.substring(0, nextHeaderIndex) +\n\n                        &quot;\\n\\n&quot; + newExcalidrawContent + &quot;\\n\\n&quot; +\n\n                        outputContent.substring(nextHeaderIndex);\n\n    } else {\n\n        // 如果没有找到自定义杂记标题，则在文件末尾添加\n\n        outputContent += `\\n\\n${customMiscHeader}\\n\\n` + newExcalidrawContent;\n\n    }\n\n}\n\n// 更新输出文件\n\nawait app.vault.modify(outputFile, outputContent);\n\nnew Notice(`✅ Excalidraw 内容已更新到文件：${outputPath}`, 2000);",
		"tags": ["1", "灵感", "数量", "note","obsidian","excalidraw","脚本"]
},

{
		"title": "在移动端设备上管理Obsidian待办和备忘的方法探讨",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/在移动端设备上管理Obsidian待办的方法探讨/",
		"content": "前言\n虽然我不提倡 all in one，但是我一直希望能使用 Obsidian 管理我的待办。虽然可以用 tasks、reminder 之类的插件来实现 Obsidian 内部的待办管理，但是对于普通人来说，手机才是真正有提醒功能的终端，而移动端 Obsidian 不能调用系统级的通知，即便它能，也会受到启动缓慢且无法常驻后台的短板的制约，因此我们需要更轻量而稳定的实现方法。\n好在 Obsidian 是基于 md 开放格式的软件，我们完全可以用其他软件来读取笔记，然后按照对应规则来解析笔记的待办。除了自行实现外，我也发现了一些应用在努力完成这样的目标。后文会介绍现有的第三方应用与自行实现的方法，宥于个人能力与精力的有限，难以做到全面准确，如有错漏，欢迎批评指正。\n自行实现\n原理分析\n首先我们要知道自行实现的原理：用 markdown 格式记录的待办就如同你用纸笔在便签上写下“明天记得买菜”，只需要让软件把“明天”和“买菜”这两个信息分别读取为时间与事项内容就好了。\n第三方应用\nnotifian（2025-01-17 更新）\n支持平台：android\n下载地址：Google play 商店\n功能介绍：扫描本地的 Obsidian 库，提取其中的待办提醒，然后在对应时间点发起提醒。\n[fold]\n\n细节：\n\n支持两种待办格式\n\nfrontmatter\n\nremind at 为提醒时间，支持精确到分钟\nrepeat 为重复规则，支持\n\n每月的第 x 天\n每 x 分钟/小时/天/周\n\n兼容 tasks 语法（因此只支持到按天提醒，不能精确到小时分钟）\n\nobsi（2025-01-17 更新）\n支持平台 ：android\n下载地址：Google play商店\n功能介绍：扫描本地的 Obsidian 库，提取其中的待办提醒，将其渲染为可视化 todo，同时可以用图形 UI 创建新的待办，支持设置截止日期、属性和种类。\n[fold]\n\n细节：\n\n通过 obsi app 创建的待办都会被放到 obsi.md 文件中，目前无法分散保存待办\n目前无法发出提醒，只能由用户自行查看\n\nObsidianAndroidWidget\n支持平台：android\n下载地址：GitHub仓库\n功能介绍：\n细节：\n\n只能手动选定链接的文件，无法按照一定的规则自动切换文件（比如根据当天日期切换当天的日记）\n\nQuickMDCapture\n通过 Android 主屏幕上的小部件添加注释：r/ObsidianMD --- Adding notes through a widget on the Android home screen : r/ObsidianMD\nKvaesitso\n支持平台：android\n下载地址：GitHub仓库\n功能介绍：这是一个开源的安卓桌面 app，它有一个自带的小组件，可以链接到一个 md 文件，然后就可以在桌面编辑这个 md 文件\n[fold]\n\n细节：\n\n只能手动选定链接的文件，而且这个文件必须由这 app 新建（当然可以手动替换）\n\n自行实现\n使用 tasker\n网友分享的思路\n\n来自 Android 的快速添加注释：r/ObsidianMD --- Quick add note from Android : r/ObsidianMD\nGuy-92/QuickNote: A way to take Quick Notes in Obsidian on Android\n\n另一个网友以此为基础进行了修改\n\n使用 Tasker 为 Android 创建“即时笔记”小部件：r/ObsidianMD --- Using Tasker To Create An &quot;Instant Note&quot; Widget For Android : r/ObsidianMD\n一个网友分享的 tasker 创建的思路，但是没有分享具体文件 使用 Tasker 为 Android 创建“即时笔记”小部件：r/ObsidianMD --- Using Tasker To Create An &quot;Instant Note&quot; Widget For Android : r/ObsidianMD\n\n我的 tasker widget\n使用 ios 捷径\niOS 快捷方式 ： r/ObsidianMD --- iOS Shortcut : r/ObsidianMD\nfv 悬浮球记笔记（偏题）\n安卓利用FV悬浮球实现不打开ob进行文本快捷输入（包括图片自动上传图床后的外链） - 经验分享 - Obsidian 中文论坛",
		"tags": [ "note","obsidian","obsidian同步","移动端"]
},

{
		"title": "让Obsidian的光标丝滑移动",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/Obsidian/让Obsidian的光标丝滑移动/",
		"content": "前言\n本文参考自 光标平滑插入动画 - 插件创意|Cursor Smooth Caret Animation\n效果展示：\n\n使用方法\n\n在插件市场安装 ninja cursor 插件\n在 Obsidian 内添加并开启以下 css[1]\nenjoy it！\n\n目前这个方案有一定缺陷：在部分插件/样式中，光标的显示位置会错位，不过实际位置是正确的\n附录\n/* Customization for the Ninja Cursor */\n.x-cursor {\nposition: inline block;\nbackground: var(--caret-color); /* Sets the Ninja Cursor Colour. */\nwidth: 1px; /* Sets the width of the Ninja Cursor. */\ntransition: all 80ms !important; /* Sets the animation delay of the Ninja Cursor. Fast typers should use a higher delay to maintain the effect. */\ntop: calc(0px - var(--header-height)); /* Ensures the cursor is inline with selected line. */\n--cursor-height: calc(var(font-size) - 2px); /* Sets Ninja Cursor Height. Font-Height variable used to ensure height matches current body text input. For a taller/shorter cursor alter the px. */\nmax-height: calc(var(--font-ui-large) * 2); /* Caps the height of the Ninja Cursor to the span of two lines. Stops Ninja Cursor spanning several lines by capping it at two. It can be capped at one but the cursor is unable to change height to match headings. */\n}\n\n/* Hides the Default Cursor */\nbody:has(.x-cursor) * {\ncaret-color: transparent;\n}\n.cm-cursorLayer {\nanimation: none !important;\ndisplay: none;\n}\n\n/* Hides the Default Ninja Cursor Dashing Effect */\n.cursorWrapper .x-cursor::after {\ndisplay: none;\n}\n\n/* Applies the Caret Blinking Effect */\n.cursorWrapper .x-cursor0 {\nanimation: blink0 1s 1s both infinite;\n}\n.cursorWrapper .x-cursor1 {\nanimation: blink1 1s 1s both infinite;\n}\n\n/* Keyframes for the Caret Blinking Effect */\n@keyframes blink1 {\n0% { opacity: 1; }\n45% { opacity: 1; }\n50% { opacity: 1;}\n95% { opacity: 1; }\n100% { opacity: 1; }\n}\n\n@keyframes blink0 {\n0% { opacity: 1; }\n45% { opacity: 1; }\n50% { opacity: 1;}\n95% { opacity: 1; }\n100% { opacity: 1; }\n}\n\n新建文件 丝滑光标.css 并粘贴上面的代码，然后把文件放入 Obsidian 的 css 文件夹中并在 Obsidian 启用 ↩︎",
		"tags": [ "note","Obsidian美化","obsidian","CSS"]
},

{
		"title": "ollama离线运行AI模型+反思翻译法+沉浸式翻译=免费又好用的翻译？最具性价比的选择！",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/效率工具/ollama离线运行AI模型-反思翻译法-沉浸式翻译-免费又好用的翻译/",
		"content": "前言\n设备需求与劝退\n本文中我使用的设备是 2020 M1 macbook pro 16g\n如果你想学习本文的操作，建议先检查自己的设备是否满足以下任一要求：\n\nmac 平台：M 系芯片的 mac，内存 16g 起步\nwindows 平台：使用显存大于 8g 的显卡\nlinux 平台：都用 linux 了，不用我教\n\n起因\n我们不能回避的一个现状是：大部分领域的英文语料都是相当有价值的，因此阅读英文依然是我们的必修课。但所幸我们已经有很多工具来减轻英语阅读的负担，以我个人为例，我最常用的两个工具是 沉浸式翻译 和 bob （macos 上的一个全局划词翻译软件）。\n其中沉浸式翻译是我在 mac、win、ios、android 四端都在使用的插件。一般我会先用沉浸式翻译的机翻来粗读文章，遇见低质翻译或长难句等需要精读英文时会使用划词翻译 + <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">反思翻译法</a>。因为现在 LLM api 的价格、并发限制与延迟，我一般不会在全局使用 LLM 翻译。粗读时往往会在沉浸式翻译自带的、开箱即用的微软翻译与 google 翻译里来回切换（因为频繁翻译会被限制，需要二者切换使用）。\n最近因为 deepseek 的开源，又开始折腾起本地部署 LLM，突然又萌生起使用本地 LLM 来做翻译的想法，测试了一下，发现 2b 的小模型做段落级翻译居然也相当不错，于是写下本文。\n配置教程\n\n安装 ollama\n（保证网络畅通）拉取模型 ollama run gemma2:2b\n在沉浸式翻译中增加一个 LLM 服务，接口为 http://127.0.0.1:11434/v1/chat/completions ，key 为 ollama ，模型为 gemma2:2b\nenjoy it\n\n效果展示\n因为发现 2b 的模型其实翻译效果也还可以，比机翻要好一点。而使用在线 LLM api 既不稳定还贵。下面我们做一下对比。\n\n依次分别为微软翻译、google 翻译、gemma2:2b、deepseek-v3（在线 api）\n为了未来对比效果，我也把原文放在这里\nIs the UK about to ban running LLMs locally?\n\nThe UK government is targetting the use of AI to generate illegal imagery, which of course is a good thing, but the wording seems like any kind of AI tool run locally can be considered illegal, as it has the *potential* of generating questionable content. Here's a quote from the news:\n\n&quot;The Home Office says that, to better protect children, the UK will be the first country in the world to make it illegal to possess, create or distribute AI tools designed to create child sexual abuse material (CSAM), with a punishment of up to five years in prison.&quot; They also mention something about manuals that teach others how to use AI for these purposes.\n\nIt seems to me that any uncensored LLM run locally can be used to generate illegal content, whether the user wants to or not, and therefore could be prosecuted under this law. Or am I reading this incorrectly?\n\n可以看到在线的 deepseek 确实爆杀了，但是 api 是要额外花钱的，还需要时间来反应。而在我的 mac 上跑 2b 的小模型，速度比在线 api 快一点，效果介于机翻和 api 之间。而机翻使用的太频繁也会触发限制，相比之下我用 ollama 跑一个 2b 的小模型，电脑也不卡，翻译速度也能接受，还不收费，岂不美哉？\n（单个网页用本地 LLM 是可以的，但是如果快速翻页 or 多个网页，本地 LLM 的速度还是不够，需要更强的配置，另外可能还要再配置一下 ollama 的同时加载模型数与单模型的并发处理数）\n因此我还是很推荐的这样做的。\n最后放上更多翻译工具的结果：\nDeepL 翻译：\n\n[!DeepL 翻译]\n英国即将禁止在本地开办法律硕士课程？\n英国政府正在打击利用人工智能生成非法图像的行为，这当然是件好事，但从措辞上看，似乎任何一种在本地运行的人工智能工具都可以被视为非法，因为它有可能生成有问题的内容。以下是新闻中的一段话：\n“内政部表示，为了更好地保护儿童，英国将成为世界上第一个规定拥有、创建或分发旨在创建儿童性虐待材料（CSAM）的人工智能工具为非法的国家，最高可判处五年监禁。” 他们还提到了一些关于教他人如何为这些目的使用人工智能的手册。\n在我看来，无论用户是否愿意，在本地运行的任何未经审查的 LLM 都可以用来生成非法内容，因此可以根据该法律进行起诉。还是我理解错了？\n\n使用反思翻译法 +deepseek-v3 得到的翻译：\n\n[!使用反思翻译法 +deepseek-v3 得到的翻译]\n英国政府正在打击利用人工智能生成非法图像的行为，这当然是件好事，但措辞似乎暗示任何本地运行的 AI 工具都可能被视为非法，因为它们有潜在生成不良内容的可能。\n以下是新闻中的一段引述：\n“内政部表示，为了更好地保护儿童，英国将成为世界上第一个将拥有、创建或分发旨在制作儿童性虐待材料（CSAM）的 AI 工具定为非法的国家，最高可判处五年监禁。”他们还提到了一些关于教别人如何使用 AI 进行这些目的的指南。\n在我看来，任何未经审查的本地运行的大型语言模型都可以用来生成非法内容，无论用户是否有意为之，因此可能会根据这项法律被起诉。还是我理解错了？\n\n在 n8n 中的 AI-agent 使用反思翻译法 +deepseek-v3 得到的翻译：\n\n[!在 n8n 中的 AI-agent 使用反思翻译法 +deepseek-v3 得到的翻译]\n英国政府正在针对使用人工智能生成非法图像的行为进行打击，这当然是件好事，但措辞似乎暗示任何本地运行的 AI 工具都可能被视为非法，因为它们有生成可疑内容的潜力。以下是新闻中的一段引述：\n内政部表示，为了更好地保护儿童，英国将成为世界上第一个将拥有、创建或分发旨在创建儿童性虐待材料（CSAM）的 AI 工具定为非法的国家，最高可判处五年监禁。他们还提到了一些关于教别人如何使用 AI 达到这些目的的手册。\n在我看来，任何本地运行的未经审查的大型语言模型（LLM）都可能被用来生成非法内容，无论用户是否有意，因此可能会根据这项法律被起诉。或者我理解错了？\n\n可以看到传统机器翻译的天花板 DeepL 的翻译结果也不尽人意，LLM 具备的上下文感知功能在翻译领域真的太强了。另外同样使用 deepseek-v3 ，不同的 prompt 也会产生不同的效果，因此 prompt 工程也很重要。",
		"tags": [ "note","LLM","ai","翻译","自托管","反思翻译法"]
},

{
		"title": "follow认证文件",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/自托管折腾/follow认证文件/",
		"content": "This message is used to verify that this feed (feedId:105271225522095104) belongs to me (userId:72208719763571712). Join me in enjoying the next generation information browser https://follow.is.\n![[assets/obsidian-icon-ico.ico]]",
		"tags": [ "note"]
},

{
		"title": "迈向爱折腾的geek的第一步：学会提问、学会查资料",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/迈向爱折腾的geek的第一步——学会提问、学会查资料/",
		"content": "迈向爱折腾的 geek 的第一步：学会提问、学会查资料\n前言\n软路由、NAS、虚拟机、群晖、qnap、unraid、PVE、esxi、proxmox、truenas、OMV、PT、刷流、保种、docker、k8s、podman、chatgpt、LLM、self-hosted、自托管、vps、typora、obsidian、思源笔记、memos、joplin、logseq、notion、heptabase、tasker、macrodroid、快捷指令、shotcuts、少数派、v2ex、穿越机、fpv、树莓派、autohotkey、Manim、github……\n这些词语有没有你熟悉的？有没有你正在关注或者学习的？如果你是一个爱折腾计算机相关的东西的人，早晚会和这些东西打交道。但是想要入门这些圈子，有门槛。这门槛说低不低，说高不高，如果你是一个爱思考、爱学习的人，相信你一定可以在这些事物中找到属于自己的乐趣。当然，如果你不具备上述特质，但是有一颗谦虚的心，也是完全 ok 的。\n或许你注意到了，本文的标题中有一个词叫“Geek”，这个词在中文里也被译为“极客”，这里我们引用一段来自百度百科的话：\n\n“极客是美国俚语 Geek 音标 [ɡiːk] 的音译。随着互联网文化的兴起，这个词含有智力超群和努力的意思，又被用于形容对计算机和网络技术有狂热兴趣并投入大量时间钻研的人。现代的 Geek 含义虽然与过去有所不同，但大多仍相似，Geek 更多是指在互联网时代创造全新的商业模式、尖端技术与时尚潮流的人。总之，是一群以创新、技术和时尚为生命意义的人，这群人共同地战斗在新经济、尖端技术和世界时尚风潮的前线，共同为现代的电子化社会文化做出自己的贡献。”\n\n在早些年，二次元文化中也常常提到一个词叫“技术宅”，它们也是有相似之处的。\n而今天我就想探讨一下，如何成为一个 Geek。\n我相信当你看到这篇文章的时候，已经不是一个完全的门外汉，很有可能你已经一只脚迈入了门槛，但是苦于找不到真正入门的办法。或许，你会觉得这个圈子里的人多少有点装逼，小白问问题经常得不到回答，老鸟们态度都很差。这里我不做价值评判，但是我可以从两个角度来分析这个问题。\n\n小白世界线 1: 我听说这个东西很有意思，于是我开始尝试，很有可能我是在 bilibili 刷到了一个视频，然后我开始跟着视频做，但是即便我按照视频的方法操作了，还是遇见了意外的问题。这个时候我开始在评论区问问题，终于，有人回答了我，但是他的回答很简略，不能解答我的问题。于是我费尽千辛万苦，终于找到了一个 QQ 群，加群的时候需要回答问题，这个问题好难啊，我也是在网上找了很久。终于我加到了 QQ 群里，一进来就弹出一个群公告，要求新人把自己的昵称改成“设备 - 型号”，什么东西？直接叉掉。然后我开始在群里问问题，一开始大家很热心，但是不知道为什么，他们越来越不耐烦，很多时候我提问，根本没有人回复。我只好隔一会儿就问一次一样的问题，然后突然有一个人开始嘲讽我，我很生气。你不就是比我多玩了几天吗？怎么这么欺负新人？我忍不住骂了他两句，然后我就被踢出群了。\n小白世界线 2:（到加群前面都一样）我加到群里，按照公告要求改好了备注，很礼貌的问了一个我刚刚遇见的问题，被一个看上去是老人的嘲讽“这也不懂还玩 xx？”\n老鸟世界线 1: 我在群里遇见一个新人，进群不看群公告，上来就问公告里写了的问题，提问不带日志，群文件里的新手入门必看都不看，但是我也能理解，毕竟大家都是从新手过来的，于是我好心的耐心的回答了他的问题。然后他开始了颐指气使，要求我帮他做这做那，我们群里几个比较热心的老哥花了一晚上的时间帮他搞定了，最后他一句谢谢都没说。大家都沉默了，之后再也没有人理过他。然后他还在接着问问题，见没人回答，他在群里破口大骂：“一群傻 *，会玩 xx 了不起啊”，骂完之后他退了群\n老鸟世界线 2: 今天打开 qq，上来就看到一个傻 x 菜鸟问个傻 x 问题，给他喷烂，哈哈真爽\n\n以上情况我都遇见过，只能说人的多样性是难以想象的。希望萌新可以保持礼貌和好学，不要做一个让人唾弃的伸手党，而在这条路上稍微先行一步的老鸟也能保持谦虚与友好，让一个圈子可以越来越繁荣，而不是故步自封，自绝于群众。\n因此我写下这篇文章，想以一个比较放松的形式来给新手一点建议，如果你想入门这些折腾的东西。那么你需要有基本的相关能力，但我也知道人和人是不一样的，可能对于一个人来说是常识的东西，在另一个人眼中都是超纲的知识。所以我们需要先建立一些共识，而这篇文章就是想抛砖引玉，企图找到这个“共识”。\n下面，就让我们探讨一下成为一个 Geek 需要的能力与素质.\n信息检索能力\n“好消息!好消息! 本群成功与百度、bing、google 等知名搜索引擎达成合作关系,以后新手有什么想问的的问题可以直接搜索,不需要在问群友了，可以省下大家很多时间!”\n\n这是一个早年间就流传在 qq 群、贴吧的表情包文案，它也反应出一个问题：很多人喜欢把群友当搜索引擎，问一些网上一搜就能搜出来的问题。这种行为在几乎所有圈子里都会引起反感，做出这种行为的人往往也会被称为“伸手党”，恰似俗话说的“衣来伸手，饭来张口”，可见古人也很讨厌这种人。\n那么如何避免成为伸手党呢？首先要摈弃思维上的惰性，遇见问题不要总想马上依赖他人，不妨先去搜索一下。要知道生在互联网时代，信息的获取几乎是免费的，如果连动动小手去搜索一下都不愿意的话， 建议别玩！\n我相信愿意听我啰嗦到这里的朋友，肯定不是上面这种人，但是很多时候还是会问出一些让人笑话的问题，这一般是因为你不会搜索。\n现代互联网社会，搜索是一门技术，现代的文盲几乎可以定义为不会使用计算机进行学习、交流的人。因此成为 Geek 第一步就是先学会如何使用搜索引擎。\n搜索引擎入门\n选对搜索引擎\n鉴于我的的能力有限，我会分享一点搜索的小技巧，希望能帮助到你。\n第一步：选对搜索引擎。不要用百度，不要用百度，不要用百度！现在百度搜索出来的结果有太多废物与广告，会让你迷失在互联网糟粕的海洋中。\n一般人建议就用必应，即 bing，这是微软推出的一个搜索引擎，网址为 cn.bing.com。\n如果你具备相关能力，在检索非中文信息的时候可以用 google。\n这里也要说一句题外话，当你发现在中文社区难以找到有价值的资料，不妨试一试英文。不要害怕看不懂，现在的翻译工具已经非常完善了，一个沉浸式翻译插件就能让你畅游外文社区。而外文社区的资料丰富度与质量还是要高不少的。\n这里也可以推荐一个视频，讲为什么要用英语：英语才是最好的计算机语言【让编程再次伟大#3】\n关键词的选择\n搜索很简单：打开搜索引擎，输入关键词，阅读结果\n搜索很难：用错引擎，选不好关键词，懂不动结果\n最关键的一步就是关键词，毕竟名字中就有“关键”\n用一句话概括如何搜索：放弃说话的方式，转而提炼一句话中不能删除的东西，也就是“关键词”。\n比如用 bing 搜索：“怎么申请 chatgpt 的 api”，得到的第一条叫“\nchatGPT 国内怎么用？答案全在这里！3 种方法随你选择”\n但如果搜索：“chatgpt api 申请”，得到的第一条结果则是“ChatGPT 初体验：注册、API Key 获取与 ChatAPI 调用”\n很明显自己在搜索前手动拆分好关键词，会比让搜索引擎自己去揣摩你想要什么要好的多，要记住你面对的是一个不懂人心的机器，而不是另一个人，因此应该由人去揣摩机器。\n当然搜索引擎的关键词有很多讲究，比如引号、加减号、site 等技巧，但这不是重点，感兴趣的大家可以自己去搜索一下。\n什么年代了，还在玩传统搜索？\n你说你不会搜索，那不妨试试 AI。自 ChatGPT 之后，大语言模型已经让搜索变得简单多了，如果你想尝试 AI 搜索，可以试试这些：\n\n秘塔搜索\n天工 AI 搜索\nKIMI\n\n我推荐了三个国内的 AI 搜索引擎，主要是便于新手接触，不代表能力优劣，当你对这个领域熟悉后，会找到适合你自己的选择。\n对于 AI 搜索来说，关键词就是反着来，你怎么想的就怎么问，不要自己去拆分关键词，AI 会主动揣摩你的意图。同时记住，AI 是有无限耐心的，你可以不断的调整自己的问题来获取答案。\n比如我在写这篇文章的时候，突然发现我的 obsidian 悬浮大纲插件不见了，可能是因为刚刚我更新了客户端，于是我去秘塔 AI 搜索“obsidian 怎么在主界面悬浮显示大纲 需要什么插件？”，它很快就给我找到了那个我忘记了名字的插件——floating-toc。但是它也犯错了，AI 说这个插件是核心插件，不需要下载。但实际上这是一个第三方插件，因此大家在使用 AI 的时候一定要注意，AI 是会编造谎话的，需要自己再去交叉信源确认真假。\n论坛信息检索\n很多论坛不支持免登录搜索，甚至查看都需要注册，这个时候可以使用搜索引擎技巧之“关键词 site:xx.com”和页面快照来快速查看论坛信息\n私域流量时代，绕不开的社群 （以 QQ 群为例）\n首先我很讨厌用通讯软件做知识分享，因为不具备可复用性，前人问过的问题被淹没在聊天记录中，后人又要问一样的问题。但是架不住大环境又如此，所以我们只能尽量去适应它。\n新加入一个群，先看群公告，再看群文件里有没有类似新手入门的东西，看完之后再说话是一种礼貌。\n提问之前先搜索群聊天记录，一般来说刚加群可以看到最近几天的聊天记录。\n以上方法都解答不了问题之后，嘴巴甜一点提问题。不要觉得别人的义务劳动是理所当然，毕竟，别人回答你的问题，又没收一分钱。\n当然 QQ 群里总是有一些优越感很强的人，可以使用 QQ 群的屏蔽此人发言功能，能有效改善自己的心情。\n学会问问题\n说到加群提问，就不得不说很多人根本不会问问题。就像文章开头说的菜鸟老鸟之争，很多时候人是被一个又一个弱智问题给逼疯的。\n参考这篇文章：如何精准表达，新手应该学习如何正确表达自己的问题。\n借用 pkmer 群公告里的一张图：\n\n我总结了一些规则：\n\n不要当伸手党，问人之前先搜索\n\n因为我经常遇见“把原问题拿去搜索，第一条就是答案”的那种提问，真的很无语\n\n直接了当，像写邮件一样提问，一段话说明来意\n\n因为总有人喜欢问“有没有用过 xx 软件”，然后双方就要进行很多不必要的对话与沟通，加上聊天软件本身就是异步的，很可能会来回拉扯很久\n\n提问方法要有信息量：遇见 bug/疑难杂症，给出复现 bug 的步骤或者日志\n\n我也经常遇见有人问“xx 用不了怎么办”，这种没有现象描述、复现流程、报错日志的提问方法看着就让人无语。算命还得要个八字呢！",
		"tags": [ "note","geek","元知识","学习方法论"]
},

{
		"title": "博客首页",
		"date":"Sat Feb 08 2025 08:13:31 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "十分冷淡存知己 一曲微茫度余生\n你好，欢迎来到独属于我的罅隙。\n我是一个重度笔记爱好者，从早期的印象笔记，到后来换用 onenote、notability、goodnotes、思源笔记、为知笔记、notion、obsidian……\n最后我选择长期使用 obsidian，从 21 年到现在，也积累了上千条笔记了。我并不觉得我的笔记做的有多好，但是做笔记让我感觉快乐。\n在探索笔记组织方式的过程中，我也产生了很多疑惑，感谢互联网上先驱者们的无私分享，因此我也在这里分享我自己的经验，如果能帮到茫茫人海中的你就最好了。\n\n[!如果你想说点什么]\n本博客支持评论功能，浏览至网页最下方时懒加载（此主页除外），欢迎留言。\n\n在哪能找到我\n\n在 Vercel 查看我的博客（中国大陆网络可正常访问）：blog.qudange.top\n在 Github page 上查看我的博客：dangehub.github.io\n使用 RSS 关注我的博客：blog.qudange.top/feed.xml\n使用 follow 关注我的博客：app.follow.is/share/feeds/105271225522095104\n\n我还运营着以下平台\nBilibili：三花猫曲奇\n我会在这里分享我的个人知识管理总结，视频和文字是一种截然不同的体验，或许你可以来看看。\n小红书：曲淡歌 - 小红书\n联系方式\n邮箱：wanyy314@foxmail.com\nDiscord：qudange\n个人微博\nMastodon、Misskey 等兼容联邦宇宙的平台关注 qudange@blogs.qudange.top\n文章时间轴\n此时间轴用 dataview 自动生成：\n\n标题\n发布时间\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Thino与Mac软件popclip联动-实现系统级全局划词摘录/\">Thino与Mac软件popclip联动-实现系统级全局划词摘录</a>\n2025-02-07\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/效率工具/ollama离线运行AI模型-反思翻译法-沉浸式翻译-免费又好用的翻译/\">ollama离线运行AI模型-反思翻译法-沉浸式翻译-免费又好用的翻译</a>\n2025-02-03\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">如何在在多个邮箱里阅读外语邮件？最好的电子邮件聚合客户端thunderbird+最好的翻译软件沉浸式翻译</a>\n2025-01-24\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/让Obsidian的光标丝滑移动/\">让Obsidian的光标丝滑移动</a>\n2025-01-24\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">在移动端设备上管理Obsidian待办的方法探讨</a>\n2025-01-17\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/自托管折腾/follow认证文件/\">follow认证文件</a>\n2025-01-12\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian插件测评/Obsidian插件测评-i18n-汉化插件、翻译词典编辑器、云端共享词典、内置沉浸式翻译/\">Obsidian插件测评-i18n-汉化插件、翻译词典编辑器、云端共享词典、内置沉浸式翻译</a>\n2025-01-11\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian插件测评/Obsidian插件测评-BetterPluginsManager-插件分组、标签管理，插件备注，延迟启动/\">Obsidian插件测评-BetterPluginsManager-插件分组、标签管理，插件备注，延迟启动</a>\n2025-01-09\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/用css让obsidian中的扫描黑白文档融入笔记背景/\">用css让obsidian中的扫描黑白文档融入笔记背景</a>\n2025-01-06\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian轻量级PPT教程/\">Obsidian轻量级PPT教程</a>\n2025-01-04\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">优化macOS的触摸板体验</a>\n2025-01-03\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">用反思翻译法提升大语言模型翻译的质量</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/我维护了一个obsidian示例库，分享了我的obsidian工作流/\">我维护了一个obsidian示例库，分享了我的obsidian工作流</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/把Obsidian发布为网页的各种方式探索/\">把Obsidian发布为网页的各种方式探索</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/多媒体制作/口播剪辑工作流探索/\">口播剪辑工作流探索</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/自托管折腾/在wordpress通过RSS来备份任何平台的信息，打造个人媒体枢纽/\">在wordpress通过RSS来备份任何平台的信息，打造个人媒体枢纽</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/自托管折腾/密码管理器：从bitwarden迁移到keepass/\">密码管理器：从bitwarden迁移到keepass</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/迈向爱折腾的geek的第一步——学会提问、学会查资料/\">迈向爱折腾的geek的第一步——学会提问、学会查资料</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地/\">Obsidian技巧之用maoxian插件剪藏网络文章，同时把图片下载到本地</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/一键把excalidraw的头脑风暴输出为线性文章/\">一键把excalidraw的头脑风暴输出为线性文章</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Anyblock插件入门/\">Anyblock插件入门</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/Obsidian/Obsidian实现复制时自动上传图片到图床/\">Obsidian实现复制时自动上传图片到图床</a>\n2024-12-30\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/AI/用n8n实现反思翻译/\">用n8n实现反思翻译</a>\n2024-12-30\n\n本网站的实现方式\n这是一个使用 obsidian-digital-garden 实现的博客，我很推荐这个插件，如果你对这种实现方式感兴趣的话，可以查看这个链接\n\n数字花园 - 免费发布黑曜石笔记 --- Digital Garden - Publish Obsidian Notes For Free",
		"tags": [ "note","gardenEntry"]
}
]